#version 450
#extension GL_EXT_debug_printf : enable

#define IS_AVAILABLE_BUFFER_PLAYER_EVENT
#define IS_AVAILABLE_BUFFER_GLOBAL_MUTABLES
#define IS_AVAILABLE_BUFFER_BONES
#define IS_AVAILABLE_BUFFER_WORLD
#define IS_AVAILABLE_BUFFER_COLLISION_GRID

#include "descriptors_compute.comp"

layout (local_size_x_id = GROUP_SIZE_CONST_ID) in;

#include "utils.comp"

struct Neighbour{
    uint velocity_component_affected;
    uint block_idx;
};

void main() {
    uint gID = gl_GlobalInvocationID.x;
    const uint bone_count = global_mutables.bones;
    if(gID==0){
        if (player_event.event_type == PLAYER_EVENT_THROW){
            // vec3_slot0 holds current player position
            // vec3_slot1 holds throwing velocity
            collision_grid[broad_phase_position_to_cell_idx(bones[0].old_center)].len = 0;
            bones[0].old_center = player_event.vec3_slot0;
            bones[0].new_center = player_event.vec3_slot0 + player_event.vec3_slot1;
        }
    }
    if (gID < bone_count){
        const Bone bone = bones[gID];
        vec3 velocity = bone.new_center - bone.old_center;
        velocity += bone.impulse * PHYSICS_SIMULATION_DELTA_TIME_PER_STEP / bone.mass;
        velocity.y -= GRAVITY * PHYSICS_SIMULATION_DELTA_TIME_PER_STEP;
        vec3 half_hitbox = vec3(bone.half_side_length,bone.half_height,bone.half_side_length);
        vec3 hitbox_from = bone.new_center-half_hitbox;
        vec3 hitbox_to = bone.new_center+half_hitbox;
        vec3 hitbox_to_ceil = ceil(hitbox_to);
        uvec3 start = uvec3(hitbox_from);
        uvec3 end = uvec3(hitbox_to_ceil);
        bvec3 is_start_limited_by_world_borders = equal(start,uvec3(0,0,0));
        bvec3 is_end_limited_by_world_borders = lessThan(WORLD_BORDERS,end);

        uint neighbours_to_check_len = 0;
        Neighbour[32] neighbours_to_check;
        bvec3 velocity_sign = lessThan(velocity,vec3(0,0,0));
        bvec3 velocity_sign_rotated = velocity_sign.yzx; // doesn't matter how we rotate this, we just need to chose one rotation and stick to it.
        ivec3 dim_of_rotated_velocity_sign = ivec3(1,2,0);
        bvec3 will_hitbox_move_to_next_block = mix(lessThan(hitbox_to_ceil, hitbox_to + velocity),lessThan(hitbox_from + velocity, vec3(start)),velocity_sign);
        for(int dim=0;dim<3;dim++){
            bool neg = velocity_sign[dim];
            if(will_hitbox_move_to_next_block[dim]){
                bool bounded_by_world_border = neg ? start[dim] == 0 : end[dim] >= WORLD_BORDERS[dim];
                if (bounded_by_world_border){
                    velocity[dim] = 0;
                } else {
                    uvec3 from = start;
                    uvec3 to = end;
                    // Every box has 6 faces and 8 edges. We need to check all the blocks that touch those faces and edges.
                    // If they do, then we zero-out the respective components of velocity vector
                    // Some optimisation can be made. If we know which direction the box is moving, we do not need to check the faces that
                    // are "behind" it. We only check those that are "in front".
                    // The code in the blow if-statement marks the region of blocks that touch a specific face.
                    if (neg){
                        from[dim]--;
                        to[dim] = start[dim];
                    } else {
                        from[dim] = end[dim];
                        to[dim]++;
                    }
                    // The if-statement below will extend this region to also include blocks touching one of the edges (if necessary).
                    if(will_hitbox_move_to_next_block[dim_of_rotated_velocity_sign[dim]]){
                        if (velocity_sign_rotated[dim]){
                            from[dim_of_rotated_velocity_sign[dim]]--;
                        } else {
                            to[dim_of_rotated_velocity_sign[dim]]++;
                        }
                    }
                    for(uint y=from.y;y<to.y;y++){
                        for(uint z=from.z;z<to.z;z++){
                            for(uint x=from.x;x<to.x;x++){
                                neighbours_to_check[neighbours_to_check_len++] = Neighbour(dim,block_pos_into_world_idx(uvec3(x,y,z)));
                            }
                        }
                    }
                }
            }
        }
        for(uint i=0;i<neighbours_to_check_len;i++){
            if(world[neighbours_to_check[i].block_idx]>=NO_OF_TRAVERSABLE_BLOCKS){ // this operation is the most expensive, because it queries global memory.
                // We can make major optimisation by factoring this out into it's own loop. This way all threads will query
                // those blocks in parallel.
                velocity[neighbours_to_check[i].velocity_component_affected] = 0;
            }
        }
       bones[gID].old_center = bone.new_center;
       bones[gID].new_center = bone.new_center + velocity;
       bones[gID].impulse = bone.impulse * IMPULSE_AVERAGING_OVER_TIMESETP;
    }
}
