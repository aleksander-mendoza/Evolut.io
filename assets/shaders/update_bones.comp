#version 450
#define IS_AVAILABLE_BUFFER_CONSTANTS
#define IS_AVAILABLE_BUFFER_BONES
#define IS_AVAILABLE_BUFFER_WORLD
#include "constants.comp"
#include "world.comp"
layout (local_size_x = 32) in;

#include "physics_descriptors.comp"

bool contains_solid_block_in(const ParticleConstants c,uvec3 from, uvec3 to){
    for(uint y=from.y;y<to.y;y++){
        for(uint z=from.z;z<to.z;z++){
            for(uint x=from.x;x<to.x;x++){
                if(world[block_pos_into_world_idx(c,uvec3(x,y,z))]>0){
                    return true;
                }
            }
        }
    }
    return false;
}

void main() {
    uint gID = gl_GlobalInvocationID.x;
    if(gID < constants.bones){
        Bone bone = bones[gID];
        bone.velocity.y -= GRAVITY;
        vec3 velocity_after_collision_detection = bone.velocity;

        vec3 hitbox_from = bone.center-vec3(bone.width,0,bone.depth);
        vec3 hitbox_to = bone.center+vec3(bone.width,bone.height,bone.depth);
        vec3 hitbox_to_ceil = ceil(hitbox_to);
        uvec3 start = uvec3(hitbox_from);
        uvec3 end = uvec3(hitbox_to_ceil);
        uvec3 world_borders = uvec3(constants.world_width,CHUNK_HEIGHT,constants.world_depth);
        bvec3 is_start_limited_by_world_borders = equal(start,uvec3(0,0,0));
        bvec3 is_end_limited_by_world_borders = lessThan(world_borders,end);

        for(int dim=0;dim<3;dim++){
            bool neg = bone.velocity[dim] < 0;
            bool will_hitbox_move_to_next_block = neg ?
                (hitbox_from[dim] + bone.velocity[dim] <= float(start[dim])) :
                (hitbox_to_ceil[dim] <= hitbox_to[dim] + bone.velocity[dim]);
            if(will_hitbox_move_to_next_block){
                bool bounded_by_world_border = neg ? start[dim] == 0 : end[dim] >= world_borders[dim];
                if (bounded_by_world_border){
                    velocity_after_collision_detection[dim] = 0;
                } else {
                    uvec3 from = start;
                    uvec3 to = end;
                    if (neg){
                        from[dim]--;
                        to[dim] = start[dim];
                    } else {
                        from[dim] = end[dim];
                        to[dim]++;
                    }
                    if(contains_solid_block_in(constants,from,to)){
                        velocity_after_collision_detection[dim] = 0;
                    }
                }
            }

        }
        bones[gID].center = bone.center += velocity_after_collision_detection;
        bones[gID].velocity = velocity_after_collision_detection;
    }
}