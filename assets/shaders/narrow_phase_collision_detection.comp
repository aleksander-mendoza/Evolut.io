#version 450
#define IS_AVAILABLE_BUFFER_CONSTANTS
#define IS_AVAILABLE_BUFFER_BONES
#define IS_AVAILABLE_BUFFER_CONSTRAINTS
#define IS_AVAILABLE_BUFFER_COLLISION_GRID
layout (local_size_x = 32) in;

#include "physics_descriptors.comp"
#include "constants.comp"
#include "world.comp"
#include "grid.comp"

void main() {
    uint gID = gl_GlobalInvocationID.x;
    const ParticleConstants c = constants;
    if (gID < c.bones){
        const Bone bone = bones[gID];
        float hitbox_size = bone_hitbox_side_half_length(bone);
        vec3 hitbox_from = bone.center-vec3(hitbox_size,0,hitbox_size);
        vec3 hitbox_to = bone.center+vec3(hitbox_size,bone.height,hitbox_size);
        vec3 hitbox_to_ceil = ceil(hitbox_to);
        uvec3 world_borders = uvec3(c.world_width,CHUNK_HEIGHT,c.world_depth);

        uint potential_collisions_len;
        uint[14*(BROAD_PHASE_CELL_CAPACITY)] potential_collisions;//14=13 neighbour cells + 1 middle cell

        uvec3 cell_pos = broad_phase_position_to_cell_pos(bone.center);
        uint cell_idx = broad_phase_cell_pos_to_cell_idx(c, cell_pos);
        uint cell_len = broad_phase_cell_len(cell_idx);
        for(int i=0;i != gID && i<cell_len;i++){// if everything is written correctly, gID must be located somewhere in this cell and the i<cell_len should never be false.
            // However, let's leave this extra check just in case, to make sure that infinite loop won't suddenly arise due to some bug earlier in the code.
            uint neighbouring_bone_idx = broad_phase_cell_elem(cell_idx,i);
            potential_collisions[potential_collisions_len++] = neighbouring_bone_idx;
        }

        uvec3[13] neighbour_cells = uvec3[13](
            // We need to check neighboring cells in collision_grid.
            // There are 27 cells (3x3) adjacent to the central cell. The central center will be treated in a special way.
            // Hence here we only need to test 26 neighbours. Moreover, since we're testing all bones in parallel, if a bone X
            // collides with bone Y, then bone Y will also collide with bone X. We want to avoid duplicate detections. Hence
            // we will only check half (13) of those neighbours, and other other half will be checked in parallel by other bones.
            ivec3(0,0,1),
            ivec3(1,0,0),
            ivec3(1,0,1),
            ivec3(1,0,-1),

            ivec3(0,1,1),
            ivec3(1,1,0),
            ivec3(1,1,1),
            ivec3(1,1,-1),

            ivec3(0,-1,1),
            ivec3(1,-1,0),
            ivec3(1,-1,1),
            ivec3(1,-1,-1),

            ivec3(0,1,0)
        );

        for(int i=0;i<13;i++){
            uvec3 neighbour_pos = cell_pos + neighbour_cells[i]; // notice that if cell_pos.x == 0, then cell_pos.x - 1 == MAX_INT, which of course must be outside of world borders
            if(all(lessThan(neighbour_pos,world_borders))){
                uint neighbour_idx = broad_phase_cell_pos_to_cell_idx(c, neighbour_pos);
                uint neighbour_len = broad_phase_cell_len(neighbour_idx);
                for(uint j=0;j<neighbour_len;j++){
                    uint neighbouring_bone_idx = broad_phase_cell_elem(neighbour_idx,j);
                    potential_collisions[potential_collisions_len++] = neighbouring_bone_idx;
                }
            }
        }

        for(int i=0;i<potential_collisions_len;i++){
            uint neighbouring_bone_idx = potential_collisions[i];
            const Bone neighbour_bone = bones[neighbouring_bone_idx];
            float neighbour_hitbox_size = bone_hitbox_side_half_length(neighbour_bone);
            vec3 neighbour_hitbox_from = neighbour_bone.center-vec3(neighbour_hitbox_size,0,neighbour_hitbox_size);
            vec3 neighbour_hitbox_to = neighbour_bone.center+vec3(neighbour_hitbox_size,neighbour_bone.height,neighbour_hitbox_size);
            if(all(lessThan(neighbour_hitbox_from, hitbox_to)) && all(lessThan(hitbox_from, neighbour_hitbox_to))){
                uint newly_assigned_constraint_idx = atomicAdd(constants.collision_constraints,1);
                constraints[newly_assigned_constraint_idx] = ;
            }
        }
    }
}
