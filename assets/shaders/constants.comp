#ifndef CONSTANTS_COMP
#define CONSTANTS_COMP

#define Face uvec2

#define XPlus 0
#define XMinus 1
#define YPlus 2
#define YMinus 3
#define ZPlus 4
#define ZMinus 5
const uint CHUNK_WIDTH = 16;
const uint CHUNK_DEPTH = 16;
const uint CHUNK_HEIGHT = 256;
const uint MAX_UINT = 4294967295;
#define GROUP_SIZE_CONST_ID 1
layout (constant_id = 1) const uint GROUP_SIZE = 32;
layout (constant_id = 2) const uint CHUNKS_X = 0;
layout (constant_id = 3) const uint CHUNKS_Z = 0;
layout (constant_id = 4) const uint FACES_TO_BE_INSERTED_CHUNK_CAPACITY = 128;
layout (constant_id = 5) const uint FACES_TO_BE_REMOVED_CHUNK_CAPACITY = 128;
layout (constant_id = 6) const uint BROAD_PHASE_CELL_SIZE = 2; // how many blocks make up the side of one cell. Each cell may then hold multiple bones
const uint BROAD_PHASE_CELL_CAPACITY = 8; // maximum number of bones that can be placed in one cell
const uint WORLD_WIDTH = CHUNKS_X*CHUNK_WIDTH;
const uint WORLD_DEPTH = CHUNKS_Z*CHUNK_DEPTH;
const uint WORLD_AREA = WORLD_WIDTH*WORLD_DEPTH;
const uint TOTAL_CHUNKS = CHUNKS_X*CHUNKS_Z;
const uint WORLD_VOLUME = WORLD_AREA*CHUNK_HEIGHT;
const uint BROAD_PHASE_CHUNK_WIDTH_IN_CELLS = CHUNK_WIDTH/BROAD_PHASE_CELL_SIZE;
const uint BROAD_PHASE_CHUNK_DEPTH_IN_CELLS = CHUNK_DEPTH/BROAD_PHASE_CELL_SIZE;
const uint BROAD_PHASE_CHUNK_HEIGHT_IN_CELLS = CHUNK_HEIGHT/BROAD_PHASE_CELL_SIZE;
const uint BROAD_PHASE_CHUNK_VOLUME_IN_CELLS = BROAD_PHASE_CHUNK_WIDTH_IN_CELLS*BROAD_PHASE_CHUNK_DEPTH_IN_CELLS*BROAD_PHASE_CHUNK_HEIGHT_IN_CELLS;
const uint BROAD_PHASE_WORLD_VOLUME_IN_CELLS = BROAD_PHASE_CHUNK_VOLUME_IN_CELLS*TOTAL_CHUNKS;
const uvec3 WORLD_BORDERS = uvec3(WORLD_WIDTH,CHUNK_HEIGHT,WORLD_DEPTH);
layout (constant_id = 100) const float BLOCK_COLLISION_FRICTION = 0.7;
layout (constant_id = 101) const float BLOCK_COLLISION_MINIMUM_BOUNCE = 0.01;
layout (constant_id = 102) const float PHYSICS_SIMULATION_DELTA_TIME_PER_STEP = 1.;
layout (constant_id = 103) const float BONE_COLLISION_FORCE_PER_AREA_UNIT = 0.01;
layout (constant_id = 104) const float IMPULSE_AVERAGING_OVER_TIMESETP = 0.2;
layout (constant_id = 105) const float GRAVITY = 0;
layout (constant_id = 106) const float DAMPING_COEFFICIENT = 0.99;
layout (constant_id = 300) const uint MAX_BONES = 128;
layout (constant_id = 301) const uint MAX_SENSORS = 128;
layout (constant_id = 302) const uint MAX_FACES = 128;
layout (constant_id = 303) const uint MAX_RANDOM_NUMBERS = 128;
//layout (constant_id = 304) const uint MAX_NEURAL_NET_LAYERS = 128;
layout (constant_id = 305) const uint MAX_TMP_FACES_COPY = 128;
//layout (constant_id = 306) const uint MAX_WORLD_BLOCKS_TO_UPDATE = 128;
layout (constant_id = 307) const uint MAX_BLOCKS_TO_BE_INSERTED_OR_REMOVED = 128;
layout (constant_id = 308) const uint MAX_FACES_TO_BE_INSERTED = 128 ;
layout (constant_id = 309) const uint MAX_FACES_TO_BE_REMOVED = 128 ;
layout (constant_id = 310) const uint MAX_HTM_ENTITIES = 128;
layout (constant_id = 311) const uint MAX_ANN_ENTITIES = 128;
layout (constant_id = 312) const uint MAX_PARTICLES = 1024;

layout (constant_id = 400) const uint SEA_LEVEL = 128;
layout (constant_id = 401) const float FREEZING_TEMPERATURE = 0.;
layout (constant_id = 402) const float SWAMP_HUMIDITY = 40.;
layout (constant_id = 403) const float DESERT_HUMIDITY = 25.;//humidity of sahara desert
layout (constant_id = 404) const float LARGE_SCALE = 64.;
layout (constant_id = 405) const float CHUNK_SCALE = 16.;
layout (constant_id = 406) const float TEMPERATURE_SCALE = 64.;
layout (constant_id = 407) const float HUMIDITY_SCALE = 64.;
layout (constant_id = 408) const float RESOURCE_TYPE_SCALE = 16.;
layout (constant_id = 409) const float HAS_RESOURCE_SCALE = 4.;

bool is_in_world_borders(uvec3 pos){
    return all(lessThan(pos,WORLD_BORDERS));
}

const uint PLAYER_EVENT_NOTHING = 0;
const uint PLAYER_EVENT_THROW = 1;
const uint PLAYER_EVENT_SET_BLOCK = 2;

struct PlayerEvent{
    vec3 vec3_slot0;
    uint u32_slot0;
    vec3 vec3_slot1;
    uint u32_slot1;
    uvec3 uvec3_slot0;
    uint event_type;
};

struct Bone{
    vec3 new_center;
    float half_side_length;//width == 2*half_side_length && depth == 2*half_side_length
    vec3 direction;
    float half_height;
    vec3 impulse;
    float mass;
    vec3 old_center;
    uint entity_idx;
    vec3 position_relative_to_parent;
    uint parent_bone_idx;
    vec4 texture_coords;//xy components hold text UV coordinates. zw components hold width and height
};

mat2 normal_vec2_to_rotation_matrix(vec2 direction){
    vec2 new_z_axis = direction;
    vec2 new_x_axis = vec2(direction.y,-direction.x);
    return mat2(new_x_axis,new_z_axis);
}
/**When you move your mouse you can rotate only in two euler angles - yaw and pitch - but you cannot rotate roll angle.
This function works analogically. The input is the direction in which you are looking. The output is a 3D rotation matrix
that first applies rotation around x axis (like moving your head left and right) and then around y axis (like moving your had up and down);
*/
mat3 normal_vec3_to_rotation_matrix(vec3 direction){
    const vec3 new_x_axis = vec3(direction.z,0,-direction.x);
    const vec3 new_y_axis = cross(direction,new_x_axis);
    return mat3(new_x_axis,new_y_axis,direction);
}

bool is_ray_intersecting_axis_aligned_box(vec3 start, vec3 distance_and_direction, const vec3 left_bottom_front_corner, const vec3 box_size) {
    const mat3x2 start_mat = mat3x2(start.yz,start.xz,start.xy);
    const vec3 right_top_back_corner = left_bottom_front_corner + box_size;
    const vec3 ratioLBF = (left_bottom_front_corner - start)/distance_and_direction;
    const vec3 ratioRTB = (right_top_back_corner - start)/distance_and_direction;
    const mat3x2 intersection_point_LBF_box_plane = start_mat + mat3x2(distance_and_direction.yz*ratioLBF.x,distance_and_direction.xz*ratioLBF.y,distance_and_direction.xy*ratioLBF.z);
    const mat3x2 intersection_point_RTB_box_plane = start_mat + mat3x2(distance_and_direction.yz*ratioRTB.x,distance_and_direction.xz*ratioRTB.y,distance_and_direction.xy*ratioRTB.z);
    return
        (all(lessThan(left_bottom_front_corner.yz, intersection_point_LBF_box_plane[0])) && all(greaterThan(intersection_point_LBF_box_plane[0], right_top_back_corner.yz)) ) ||
        (all(lessThan(left_bottom_front_corner.xz, intersection_point_LBF_box_plane[1])) && all(greaterThan(intersection_point_LBF_box_plane[1], right_top_back_corner.xz)) ) ||
        (all(lessThan(left_bottom_front_corner.xy, intersection_point_LBF_box_plane[2])) && all(greaterThan(intersection_point_LBF_box_plane[2], right_top_back_corner.xy)) ) ||
        (all(lessThan(left_bottom_front_corner.yz, intersection_point_RTB_box_plane[0])) && all(greaterThan(intersection_point_RTB_box_plane[0], right_top_back_corner.yz)) ) ||
        (all(lessThan(left_bottom_front_corner.xz, intersection_point_RTB_box_plane[1])) && all(greaterThan(intersection_point_RTB_box_plane[1], right_top_back_corner.xz)) ) ||
        (all(lessThan(left_bottom_front_corner.xy, intersection_point_RTB_box_plane[2])) && all(greaterThan(intersection_point_RTB_box_plane[2], right_top_back_corner.xy)) )
    ;
}

bool is_ray_intersecting_bone(vec3 start, vec3 distance_and_direction, const Bone bone) {
    const vec3 half_size = vec3(bone.half_side_length,bone.half_height,bone.half_side_length);
    return is_ray_intersecting_axis_aligned_box(start,distance_and_direction,bone.new_center - half_size, 2*half_size);
}

struct CollisionCell{
    uint len;
    uint contents[BROAD_PHASE_CELL_CAPACITY];
};


struct GlobalMutables{
    int blocks_to_be_inserted_or_removed;
    uint bones;
    uint lidars;
    int held_bone_idx; // player can grab a bone and pull it somewhere
    int tick;
    uint htm_entities;
    uint ann_entities;
    uint particles;
};

struct FaceRelocation{
    uint dst_offset;
    Face face;
};

struct Particle{
    vec3 position;
    uint emitter_entity;
    vec3 velocity;
    float energy;
};

////////////////////////////////////////////////////////////////////////////////////
///////////// BELOW ARE GENERIC UTILITY FUNCTIONS FOR CONVERTING WORLD/FACE POSITIONS TO BUFFER INDICES ETC
////////////////////////////////////////////////////////////////////////////////////


uint chunk_pos_into_chunk_idx(uint x, uint z) {
    return z * CHUNKS_X + x;
}
uint block_pos_into_chunk_idx(uint x,uint z){
    return chunk_pos_into_chunk_idx(x / CHUNK_WIDTH, z / CHUNK_DEPTH);
}
uint block_pos_into_world_idx(uvec3 pos){
    return pos.z * WORLD_WIDTH + pos.x + pos.y * WORLD_AREA;
}
uvec3 world_idx_into_block_pos(uint idx){
    uint y = idx / WORLD_AREA;
    uint y_rem = idx - y*WORLD_AREA;
    uint z = y_rem / WORLD_WIDTH;
    uint x = y_rem - z * WORLD_WIDTH;
    return uvec3(x,y,z);
}

uint world_xz_pos_into_2d_idx(uvec2 pos){
    return pos.y*WORLD_WIDTH + pos.x;
}
uvec2 world_2d_idx_into_xz_pos(uint idx){
    uint z = idx / WORLD_WIDTH;
    uint x = idx - z * WORLD_WIDTH;
    return uvec2(x,z);
}


uint block_pos_relative_to_chunk_into_block_idx_relative_to_chunk(uvec3 position_relative_to_chunk) {
    //Notice that this conversion could equivalently be expressed as
    // position_relative_to_chunk.x + position_relative_to_chunk.z << 4 + position_relative_to_chunk.y << 8
    return position_relative_to_chunk.x+(position_relative_to_chunk.y*CHUNK_DEPTH+position_relative_to_chunk.z)*CHUNK_WIDTH;
}

uvec3 broad_phase_position_to_cell_pos(vec3 position){
    return uvec3(position/(BROAD_PHASE_CELL_SIZE));
}
uint broad_phase_cell_pos_to_cell_idx(uvec3 cell_position){
    return cell_position.x+(cell_position.y+cell_position.z*BROAD_PHASE_CHUNK_HEIGHT_IN_CELLS)*CHUNKS_X*BROAD_PHASE_CHUNK_WIDTH_IN_CELLS;
}
uint broad_phase_position_to_cell_idx(vec3 position){
    return broad_phase_cell_pos_to_cell_idx(broad_phase_position_to_cell_pos(position));
}

uint opposite_orientation(uint orientation) {
    return orientation + (bool(orientation & 1u) ? -1:+1);
}
uint orientation_for_dim_and_dir(uint dimension, bool minus_direction) {
    return dimension*2+uint(minus_direction);
}
uint block_pos_relative_to_chunk_and_orientation_into_face_coords(uvec4 position_relative_to_chunk_and_orientation) {
    return ((
    position_relative_to_chunk_and_orientation.w*256+
    position_relative_to_chunk_and_orientation.z)*256+
    position_relative_to_chunk_and_orientation.y)*256+
    position_relative_to_chunk_and_orientation.x;
}

uvec4 face_coords_into_block_pos_relative_to_chunk_and_orientation(uint face_coords) {
    uint x = face_coords & 255u;
    uint y = face_coords/256 & 255u;
    uint z = face_coords/(256*256) & 255u;
    uint w = face_coords/(256*256*256) & 255u;
    return uvec4(x,y,z,w);
}

bool face_coords_have_the_same_pos(uint face_coords1, uint face_coords2) {
    return (face_coords1 | 0xFF000000u) == (face_coords2 | 0xFF000000u);
}

uint pack_chunk_pos_and_tex_id(uint chunk_x, uint chunk_z, uint texture_id) {
    return texture_id*256*256+(chunk_x + chunk_z*256);
}

uvec2 new_face(uvec3 block_position_relative_to_chunk, uint orientation, uint chunk_x, uint chunk_z, uint texture_id){
    uint face_coords = block_pos_relative_to_chunk_and_orientation_into_face_coords(uvec4(block_position_relative_to_chunk,orientation));
    uint tex_id = pack_chunk_pos_and_tex_id(chunk_x, chunk_z, texture_id);
    return uvec2(face_coords,tex_id);
}

///////////////////////////////////////////////////////////////////////////////////
///////////// BELOW ARE DEFINITIONS OF ALL AVAILABLE INDIRECT DISPATCH BUFFERS
///////////////////////////////////////////////////////////////////////////////////

const uint DISPATCH_INDIRECT_UPDATE_PARTICLES = 0;
const uint DISPATCH_INDIRECT_PER_PARTICLE = 0;
const uint DISPATCH_INDIRECT_BROAD_PHASE_COLLISION_DETECTION = 1;
const uint DISPATCH_INDIRECT_BROAD_PHASE_COLLISION_DETECTION_CLEANUP = 1;
const uint DISPATCH_INDIRECT_UPDATE_BONES = 1;
const uint DISPATCH_INDIRECT_PER_BONE = 1;
const uint DISPATCH_INDIRECT_AGENT_SENSORY_INPUT_UPDATE = 2;
const uint DISPATCH_INDIRECT_UPDATE_AMBIENCE = 3;
const uint DISPATCH_INDIRECT_UPDATE_AMBIENCE_FACES = 4;
const uint DISPATCH_INDIRECT_UPDATE_AMBIENCE_FLUSH_WORLD_COPY = 4;
const uint DISPATCH_INDIRECT_PER_BLOCKS_TO_BE_INSERTED_OR_REMOVED = 4;
const uint DISPATCH_INDIRECT_PER_HTM_ENTITIES = 5;
const uint DISPATCH_INDIRECT_PER_ANN_ENTITIES = 6;
const uint DISPATCH_INDIRECT_LEN = 7;
const uint DRAW_INDIRECT_BONES = 0;
const uint DRAW_INDIRECT_FACES = 1;
const uint DRAW_INDIRECT_PARTICLES = 2;
const uint DRAW_INDIRECT_LEN = 3;

const uint GROUP_SIZE_MINUS_ONE = GROUP_SIZE-1;
uint invokation_count_to_group_count(uint invokations){
    return (invokations+GROUP_SIZE_MINUS_ONE)/GROUP_SIZE;
}
struct DispatchIndirectCommand{
    uint    x;
    uint    y;
    uint    z;
};
struct DrawIndirectCommand{
    uint vertex_count;
    uint instance_count;
    uint first_vertex;
    uint first_instance;
};


//////////////////////////////////////////////////////////////////////////////////
/////////// BELOW ARE SOME GENERIC MATH FUNCTIONS
//////////////////////////////////////////////////////////////////////////////////


uint max_vec3_component(vec3 v){
    return v.x > v.y ? (v.x > v.z ? 0 : 2) : (v.y > v.z ? 1 : 2);
}
uint min_vec3_component(vec3 v){
    return v.x < v.y ? (v.x < v.z ? 0 : 2) : (v.y < v.z ? 1 : 2);
}

vec4 quat_conj(vec4 q)
{
    return vec4(-q.x, -q.y, -q.z, q.w);
}

vec4 quat_mult(vec4 q1, vec4 q2)
{
    vec4 qr;
    qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);
    qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);
    qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);
    qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);
    return qr;
}

vec3 quat_rotate_vec(vec4 q, vec3 v){
    return quat_mult(q,quat_mult(vec4(v,0.),quat_conj(q))).xyz;
}

float smoothstep(float x) {
    return x * x * (3. - 2. * x);
}
float smoothstep_between(float x, float edge0,float edge1){
    return edge0 + smoothstep(x)*(edge1-edge0);
}
float smoothstep_on_2d_plane(float x, float z, float right_top, float right_bottom,float left_top, float left_bottom){
    const float val_left = smoothstep_between(z, left_bottom, left_top);
    const float val_right = smoothstep_between(z, right_bottom, right_top);
    return smoothstep_between(x, val_left, val_right);
}

////////////////////////////////////////////////////////////////////////////////
///////// BELOW ARE DEFINITIONS OF BLOCKS AND BLOCK KPROPERTIES
////////////////////////////////////////////////////////////////////////////////

struct BlockProp{
    uint[6] texture_ids;
    float opacity; // the higher, the more opaque
    float mass;
};

#define Block uint

const uint BLOCK_ID_AIR = 0;
const uint BLOCK_ID_WATER = 1;
const uint BLOCK_ID_LAVA = 2;
// blocks above are traversable. Blocks below are solid (Notice
// that if a block is traversable, player's camera might get inside it.
// When that happens the block's faces will be culled. This means that every
// traversable block must be transparent to prevent a situation where
// the player could see through walls)
const uint BLOCK_ID_GLASS = 3;
const uint BLOCK_ID_ICE = 4;
const uint BLOCK_ID_SWAMP_LEAVES = 5;
const uint BLOCK_ID_GOLDEN_LEAVES = 6;
const uint BLOCK_ID_OAK_LEAVES = 7;
const uint BLOCK_ID_PEACH_LEAVES = 8;
const uint BLOCK_ID_AETHER_LEAVES = 9;
const uint BLOCK_ID_FROST_LEAVES = 10;
// blocks above are transparent. Blocks below are not
const uint BLOCK_ID_STONE = 11;
const uint BLOCK_ID_GOLD_ORE = 12;
const uint BLOCK_ID_IRON_ORE = 13;
const uint BLOCK_ID_COAL_ORE = 14;
const uint BLOCK_ID_DIAMOND_ORE = 15;
const uint BLOCK_ID_REDSTONE_ORE = 16;
const uint BLOCK_ID_DIRT = 17;
const uint BLOCK_ID_SWAMP_DIRT = 18;
const uint BLOCK_ID_IRON_RICH_DIRT = 19;
const uint BLOCK_ID_AETHER_DIRT = 20;
const uint BLOCK_ID_FROST_DIRT = 21;
const uint BLOCK_ID_GRASS = 22;
const uint BLOCK_ID_BERRIES = 23;
const uint BLOCK_ID_STRAWBERRIES = 24;
const uint BLOCK_ID_WHEAT = 25;
const uint BLOCK_ID_SWAMP_GRASS = 26;
const uint BLOCK_ID_SWAMP_BERRIES = 27;
const uint BLOCK_ID_SWAMP_BACKBERRIES = 28;
const uint BLOCK_ID_FROST_GRASS = 29;
const uint BLOCK_ID_SNOW_CROCUS = 30;
const uint BLOCK_ID_SNOW_BLACKBERRIES = 31;
const uint BLOCK_ID_PLANK = 32;
const uint BLOCK_ID_SLAB = 33;
const uint BLOCK_ID_BRICK = 34;
const uint BLOCK_ID_COBBLESTONE = 35;
const uint BLOCK_ID_BEDROCK = 36;
const uint BLOCK_ID_SAND = 37;
const uint BLOCK_ID_RARE_SAND = 38;
const uint BLOCK_ID_GRAVEL = 39;
const uint BLOCK_ID_WET_GRAVEL = 40;
const uint BLOCK_ID_OAK_WOOD = 41;
const uint BLOCK_ID_OAK_STEM = 42;
const uint BLOCK_ID_PINK_WOOD = 43;
const uint BLOCK_ID_PINK_STEM = 44;
const uint BLOCK_ID_DARK_WOOD = 45;
const uint BLOCK_ID_DARK_STEM = 46;
const uint BLOCK_ID_OBSIDIAN = 47;
const uint BLOCK_ID_SPONGE = 48;
const uint BLOCK_ID_SNOW = 49;
const uint BLOCKS_LEN = 50;
const uint NO_OF_TRAVERSABLE_BLOCKS = 3; // every traversable block (mobs can pass through it without colliding) is transparent but the opposite may not necessarily hold
const uint NO_OF_TRANSPARENT_BLOCKS = 11; // The blocks are aligned in such a way that transparent blocks come first. Hence in
// order to check whether a block is transparent or not, it's enough to just check if its ID is below this value

#define new_block_prop_regular_transparent(texture_id, opacity, mass) BlockProp(uint[6](texture_id,texture_id,texture_id,texture_id,texture_id,texture_id),opacity,mass)
#define new_block_prop_regular( texture_id, mass) new_block_prop_regular_transparent(texture_id,1.,mass)
#define new_block_prop_top_sides_bottom_transparent( texture_id_top, texture_id_side, texture_id_bottom, opacity, mass) BlockProp(uint[6](texture_id_side,texture_id_side,texture_id_top,texture_id_bottom,texture_id_side,texture_id_side),opacity, mass)
#define new_block_prop_top_sides_bottom_front( texture_id_top, texture_id_side, texture_id_bottom, texture_id_front, mass) BlockProp(uint[6](texture_id_side,texture_id_side,texture_id_top,texture_id_bottom,texture_id_side,texture_id_front),1., mass)
#define new_block_prop_top_sides_bottom(texture_id_top, texture_id_side, texture_id_bottom, mass) new_block_prop_top_sides_bottom_transparent(texture_id_top,texture_id_side,texture_id_bottom,1., mass)

const BlockProp[BLOCKS_LEN] BLOCK_PROPS = BlockProp[BLOCKS_LEN](
    new_block_prop_regular_transparent( /*Some dummy value*/256, 0., 0.05), // air
    new_block_prop_regular_transparent( 44, 0.09, 1.0), // water
    new_block_prop_regular_transparent( 45, 0.009, 3.011), // lava
    new_block_prop_regular_transparent( 54, 0.1, 0.1), // glass
    new_block_prop_regular_transparent( 46, 0.7, 0.9167), // ice
    new_block_prop_regular_transparent( 47, 0.1, 0.143), // swamp_leaves
    new_block_prop_regular_transparent( 48, 0.1, 0.143), // golden_leaves
    new_block_prop_regular_transparent( 49, 0.1, 0.143), // oak_leaves
    new_block_prop_regular_transparent( 50, 0.1, 0.143), // peach_leaves
    new_block_prop_regular_transparent( 51, 0.1, 0.143), // aether_leaves
    new_block_prop_regular_transparent( 52, 0.1, 0.143), // frost_leaves
    new_block_prop_regular( 18, 2.26796), // stone
    new_block_prop_regular( 19, 2.9), // gold_ore
    new_block_prop_regular( 20, 2.7), // iron_ore
    new_block_prop_regular( 21, 2.0), // coal_ore
    new_block_prop_regular( 22, 2.1), // diamond_ore
    new_block_prop_regular( 23, 2.2), // redstone_ore
    new_block_prop_regular( 5, 1.3), // dirt
    new_block_prop_regular( 10, 1.3), // swamp_dirt
    new_block_prop_regular( 11, 1.3), // iron_rich_dirt
    new_block_prop_regular( 12, 1.3), // aether_dirt
    new_block_prop_regular( 17, 1.3), // frost_dirt
    new_block_prop_top_sides_bottom( 3, 4,5, 1.4), // grass
    new_block_prop_top_sides_bottom( 0, 4,5, 1.4), // berries
    new_block_prop_top_sides_bottom( 1, 4,5, 1.4), // strawberries
    new_block_prop_top_sides_bottom( 2, 4,5, 1.4), // wheat
    new_block_prop_top_sides_bottom( 8,9,10, 1.4), // swamp_grass
    new_block_prop_top_sides_bottom( 6,9,10, 1.4), // swamp_berries
    new_block_prop_top_sides_bottom( 7,9,10, 1.4), // swamp_backberries
    new_block_prop_top_sides_bottom( 15,16,17, 1.4), // frost_grass
    new_block_prop_top_sides_bottom( 13,16,17, 1.4), // snow_crocus
    new_block_prop_top_sides_bottom( 14,16,17, 1.4), // snow_blackberries
    new_block_prop_regular( 41, 1.5/4.), // plank
    new_block_prop_regular( 42, 2.26796), // slab
    new_block_prop_regular( 43, 1.9), // brick
    new_block_prop_regular( 35, 2.26796), // cobblestone
    new_block_prop_regular( 36, 3.1), // bedrock
    new_block_prop_regular( 38, 1.62), // sand
    new_block_prop_regular( 37, 1.62), // rare_sand
    new_block_prop_regular( 40, 1.68), // gravel
    new_block_prop_regular( 39, 1.68), // wet_gravel
    new_block_prop_top_sides_bottom( 26,25,26, 1.5), // oak_wood
    new_block_prop_top_sides_bottom( 26,24,26, 1.5), // oak_stem
    new_block_prop_top_sides_bottom( 29,28,29, 1.5), // pink_wood
    new_block_prop_top_sides_bottom( 29,27,29, 1.5), // pink_stem
    new_block_prop_top_sides_bottom( 32,31,32, 1.5), // dark_wood
    new_block_prop_top_sides_bottom( 32,30,32, 1.5), // dark_stem
    new_block_prop_regular( 33, 3.1), // obsidian
    new_block_prop_regular( 34, 0.1), // sponge
    new_block_prop_regular( 15, 0.05) // snow
);

const uint ENTITY_LIDAR_COUNT = 32;
const uint HTM_INPUT_SIZE = (ENTITY_LIDAR_COUNT)*(BLOCKS_LEN);
const uint HTM_MINICOLUMNS = 64;
const float HTM_POTENTIAL_POOL_SPARSITY = 0.4; // the fraction of input that constitutes potential pool of a minicolumn
const uint HTM_TOTAL_FEEDFORWARD_CONNECTIONS = uint(HTM_INPUT_SIZE*HTM_POTENTIAL_POOL_SPARSITY);
const uint HTM_FEEDFORWARD_CONNECTIONS_PER_MINICOLUMN = 32;
const uint ENTITY_BLOCK_SLOTS = 8;
const uint HTM_MINICOLUMN_LAYERS = 6;
const float HTM_PERMANENCE_THRESHOLD = 0.1;
const uint HTM_LIMIT_OF_MINICOLUMNS_TO_ACTIVATE = HTM_MINICOLUMNS/8;
const float HTM_PERMAMENCE_DECREMENT = -0.04;
const float HTM_PERMAMENCE_INCREMENT = 0.08;
const uint HTM_MAX_SEGMENTS = 4;
const uint HTM_CONTEXT_CONNECTIONS_PER_MINICOLUMN = 16;

struct HtmFeedforwardConnection{
    uint minicolumn_id;
    float permanence;
    uint input_id;
};
struct HtmContextConnection{
    uint minicolumn_id;
    float permanence;
    uint segment_id;
};
struct HtmMinicolumn{
    uint active_layer; // there can be only one active neuron in each minicolumns, except when the columns is bursting.
    // Bursting is represented with number HTM_MINICOLUMN_LAYERS. If the minicolumn is not active then the value is HTM_MINICOLUMN_LAYERS+1
    HtmContextConnection[HTM_CONTEXT_CONNECTIONS_PER_MINICOLUMN] context_connections;
    uint[HTM_FEEDFORWARD_CONNECTIONS_PER_MINICOLUMN] feedforward_connection_indices;
};
struct HtmInput{
    bool is_active;
    uint feedforward_connections_offset;
    uint feedforward_connections_len;
};
struct HtmEntity{
    uint[ENTITY_LIDAR_COUNT] lidars;
    HtmFeedforwardConnection[HTM_TOTAL_FEEDFORWARD_CONNECTIONS] htm_feedforward_connections;
    HtmMinicolumn[HTM_MINICOLUMNS] htm_minicolumns;
    HtmInput[HTM_INPUT_SIZE] htm_inputs;
    uint bone_idx;
    uint main;
    float energy;
    float speed;
    float max_speed;
};

const uint ANN_LIDAR_COUNT = 32;
const uint ANN_INPUT_SIZE = ANN_LIDAR_COUNT;
const uint ANN_HIDDEN_SIZE = 32;
const uint ANN_INPUT_CONNECTIONS_PER_HIDDEN_NEURON = 16;
const uint ANN_LATENT_SIZE = 32;
const uint ANN_HIDDEN_CONNECTIONS_PER_LATENT_NEURON = 4;
const uint ANN_LATENT_CONNECTIONS_PER_LATENT_NEURON = 4;
const uint ANN_OUTPUT_SIZE = 32;
const uint ANN_LATENT_CONNECTIONS_PER_OUTPUT_NEURON = 4;
const uint ANN_MAX_SIZE = max(max(max(ANN_HIDDEN_SIZE,ANN_LATENT_SIZE),ANN_OUTPUT_SIZE),ANN_INPUT_SIZE);
struct AnnSparseConnection{
    uint src_neuron;
    float weight;
};
struct AnnLidar{
    vec3 direction;
    float dummy;
};
struct AnnSparseHiddenNeuron{
    AnnSparseConnection[ANN_INPUT_CONNECTIONS_PER_HIDDEN_NEURON] incoming;
    float bias;
};
struct AnnSparseLatentNeuron{
    AnnSparseConnection[ANN_HIDDEN_CONNECTIONS_PER_LATENT_NEURON] incoming_from_hidden;
    AnnSparseConnection[ANN_LATENT_CONNECTIONS_PER_LATENT_NEURON] recurrent_from_latent;
    float bias;
};
struct AnnSparseOutputNeuron{
    AnnSparseConnection[ANN_LATENT_CONNECTIONS_PER_OUTPUT_NEURON] incoming;
    float bias;
};
struct AnnEntity{
    AnnSparseHiddenNeuron[ANN_HIDDEN_SIZE] ann_hidden;
    AnnSparseLatentNeuron[ANN_LATENT_SIZE] ann_latent;
    AnnSparseOutputNeuron[ANN_OUTPUT_SIZE] ann_output;
    float[ANN_LATENT_SIZE] latent;
    AnnLidar[ENTITY_LIDAR_COUNT] lidars;
    uint bone_idx;
    uint main;
    float energy;
    float speed;
    float max_speed;
};


///////////////////////////////////////////////////////////////////////////
///////////////// BELOW SECTION CONTAINS CONSTANTS AND DEFINITIONS USED BY WORLD GENERATOR
///////////////////////////////////////////////////////////////////////////

const uint BIOME_ID_ARCTIC_DESERT = 0;
const uint BIOME_ID_TAIGA = 1;
const uint BIOME_ID_ARCTIC = 2;
const uint BIOME_ID_DESERT = 3;
const uint BIOME_ID_PLAINS = 4;
const uint BIOME_ID_SWAMP = 5;
const uint BIOME_COUNT = 6;
uint get_biome(float humidity,float temperature){
    uint freezing = uint(temperature < FREEZING_TEMPERATURE);
    uint dry = uint(humidity > DESERT_HUMIDITY) + uint(humidity > SWAMP_HUMIDITY);
    return freezing*3+dry;
}
const uint MAX_BIOME_RESOURCES = 4;
const uint MAX_BIOME_SURFACE_ARTIFACTS = 4;
struct BiomeRes{
    uint res;
    float prob;
};
struct BiomeProp{
    Block dirt;
    Block grass;
    Block water_top;
    uint sea_depth;
    BiomeRes[MAX_BIOME_RESOURCES] resources;
    BiomeRes[MAX_BIOME_SURFACE_ARTIFACTS] surface_artifacts;
};
uint get_biome_resource(const BiomeProp biome, float random_value){
    for(uint i=0;i<MAX_BIOME_RESOURCES;i++){
        if(random_value < biome.resources[i].prob){
            return biome.resources[i].res;
        }
    }
    return biome.grass;
}
uint get_biome_surface_artifact(const BiomeProp biome, float random_value){
    for(uint i=0;i<MAX_BIOME_SURFACE_ARTIFACTS;i++){
        if(random_value < biome.surface_artifacts[i].prob){
            return biome.surface_artifacts[i].res;
        }
    }
    return BLOCK_ID_AIR;
}
#define biome_res4(prob,res0,prob0,res1,prob1,res2,prob2,res3,prob3) BiomeRes[MAX_BIOME_RESOURCES](BiomeRes(res0,prob*prob0),BiomeRes(res1,prob*(prob0+prob1)),BiomeRes(res2,prob*(prob0+prob1+prob2)),BiomeRes(res3,prob*(prob0+prob1+prob2+prob3)))
#define biome_res3(prob,res0,prob0,res1,prob1,res2,prob2) biome_res4(prob,res0,prob0,res1,prob1,res2,prob2,BLOCK_ID_AIR,-1)
#define biome_res2(prob,res0,prob0,res1,prob1) biome_res3(prob,res0,prob0,res1,prob1,BLOCK_ID_AIR,-1)
#define biome_res1(prob,res0,prob0) biome_res2(prob,res0,prob0,BLOCK_ID_AIR,-1)
#define biome_res0 biome_res1(1,BLOCK_ID_AIR,-1)

const BiomeProp[BIOME_COUNT] BIOMES = BiomeProp[BIOME_COUNT](
    BiomeProp(BLOCK_ID_DIRT,BLOCK_ID_GRASS,BLOCK_ID_WATER,0,biome_res3(0.1,BLOCK_ID_BERRIES,0.5,BLOCK_ID_STRAWBERRIES,0.25,BLOCK_ID_WHEAT,0.25),biome_res2(0.01,BLOCK_ID_OAK_STEM,0.8,BLOCK_ID_PINK_STEM,0.2)),//BIOME_ID_PLAINS
    BiomeProp(BLOCK_ID_SAND,BLOCK_ID_SAND,BLOCK_ID_WATER,0,biome_res0,biome_res1(0.01,BLOCK_ID_AETHER_LEAVES,1)),//BIOME_ID_DESERT
    BiomeProp(BLOCK_ID_FROST_DIRT,BLOCK_ID_FROST_DIRT,BLOCK_ID_ICE,15,biome_res0,biome_res1(0.01,BLOCK_ID_FROST_LEAVES,1)),//BIOME_ID_ARCTIC_DESERT
    BiomeProp(BLOCK_ID_FROST_DIRT,BLOCK_ID_FROST_GRASS,BLOCK_ID_ICE,5,biome_res2(0.1,BLOCK_ID_SNOW_BLACKBERRIES, 0.4,BLOCK_ID_SNOW_CROCUS,0.6),biome_res2(0.01,BLOCK_ID_OAK_STEM, 0.8,BLOCK_ID_FROST_LEAVES,0.2)),//BIOME_ID_TAIGA
    BiomeProp(BLOCK_ID_FROST_DIRT,BLOCK_ID_SNOW,BLOCK_ID_ICE,15,biome_res2(0.05,BLOCK_ID_SNOW_BLACKBERRIES,0.4,BLOCK_ID_SNOW_CROCUS,0.6),biome_res1(0.01,BLOCK_ID_FROST_LEAVES,1)),//BIOME_ID_ARCTIC
    BiomeProp(BLOCK_ID_SWAMP_DIRT,BLOCK_ID_SWAMP_GRASS,BLOCK_ID_WATER,0,biome_res2(0.15,BLOCK_ID_SWAMP_BACKBERRIES, 0.5,BLOCK_ID_SWAMP_BERRIES,0.5),biome_res2(0.01,BLOCK_ID_OAK_STEM, 0.8,BLOCK_ID_DARK_STEM,0.2))//BIOME_ID_SWAMP
);

#endif // CONSTANTS_COMP