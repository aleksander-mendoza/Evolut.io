#version 450


#define CHUNK_WIDTH 16
#define CHUNK_DEPTH 16
#define CHUNK_HEIGHT 256
#define GRID_GRANULARITY 4 // the total number of cells in a block is GRID_GRANULARITY raised to the power of 3
#define CELL_SIZE 1./(GRID_GRANULARITY)
#define CELL_DIAGONAL sqrt(3.)*(CELL_SIZE)
#define PARTICLE_RADIUS (CELL_DIAGONAL)/2 //the is the minimum possible particle size that still guarantees
// only one particle will fall into each grid cell. Here we assume that the center of particle decides,
// which cell a particel falls into. The particles should normally never overlap... well... sporadically it may happen
// that they do, especially if they are moving with high speeds and suddenly collide. But such events should be rare
// and if they do occur, only one fo them will be randomly picked to occupy the grid cell, while the other one will
// be ignored. But in the next simulation step, the particle positions will almost surely change and the two particles
// should at some point fall into different cells and then collision will be detected.
#define PARTICLE_DIAMETER (PARTICLE_RADIUS)*2
#define CHUNK_WIDTH_IN_CELLS CHUNK_WIDTH*GRID_GRANULARITY
#define CHUNK_DEPTH_IN_CELLS CHUNK_DEPTH*GRID_GRANULARITY
#define CHUNK_HEIGHT_IN_CELLS CHUNK_HEIGHT*GRID_GRANULARITY
#define PARTICLE_COLLISION_DISTANCE_SQUARE (PARTICLE_DIAMETER)*(PARTICLE_DIAMETER)
layout (local_size_x = 256) in;

layout(set = 0, binding = 0) uniform Config{
    int predefinedConstraints;
    int chunks_x;
    int chunks_z;
} config;

layout(set = 0, binding = 1) readonly buffer  Particles{
    vec4 particles[];
} particles;

layout(set = 0, binding = 2) readonly buffer  World{
    uint blocks[];
} world;

layout(set = 0, binding = 3) buffer  Grid{
    uint cells[]; // collision detection is based on the very common approach of using a grid
} grid;

layout(set = 0, binding = 4) buffer Constraints{
    mat4 matrices[];
} constraints;

int cell_position_to_idx(ivec3 cell_positon){
    return cell_position.x+(cell_position.y+cell_position.z*CHUNK_HEIGHT_IN_CELLS)*CHUNK_WIDTH_IN_CELLS;
}
void main()
{
    //grab global ID
    uint gID = gl_GlobalInvocationID.x;
    for(int chunk_x=0;chunk_x<chunks_x;chunk_x++){
        for(int chunk_z=0;chunk_z<chunks_z;chunk_z++){
            vec4 particle = particles.particle[gID];
            vec3 particle_position = particle.xyz;
            float particle_weight = particle.w;
            if(int(particle.x)/CHUNK_WIDTH==chunk_x && int(particle.z)/CHUNK_DEPTH==chunk_z){
                particle.x -= chunk_x*CHUNK_WIDTH; //now we will be working in coordinate system
                particle.z -= chunk_z*CHUNK_DEPTH; //that is relative to this particular chunk
                ivec3 cell_position = ivec3(particle.xyz/CELL_SIZE);
                grid.cells[cell_position_to_idx(cell_position)] = gID;
                ivec2 x_range=(cell_position.x+ivec2(-1,2)).clamp(0,CHUNK_WIDTH_IN_CELLS);
                ivec2 y_range=(cell_position.y+ivec2(-1,2)).clamp(0,CHUNK_HEIGHT_IN_CELLS);
                ivec2 z_range=(cell_position.z+ivec2(-1,2)).clamp(0,CHUNK_DEPTH_IN_CELLS);
                for(int x=x_range.x;x<x_range.y;x++) {
                    for(int y=y_range.x;y<y_range.y;y++) {
                        for(int z=z_range.x;z<z_range.y;z++) {
                            int cell_idx = cell_position_to_idx(ivec3(x,y,z));
                            uint neighbour_particle_idx = grid.cells[cell_idx];
                            vec4 neighbour_particle = particles.particle[neighbour_particle_idx];
                            vec3 neighbour_particle_position = neighbour_particle.xyz;
                            if(dot(particle_position,neighbour_particle_position)<=PARTICLE_COLLISION_DISTANCE_SQUARE){
                                atomicAdd(
                            }
                        }
                    }
                }
            }
        }
    }
    //make sure we don't access past the buffer size
    if(gID < opData.matrixCount)
    {
        // do math
        outputData.matrices[gID] = sourceData.matrices[gID] * opData.transform;
    }
}

