#ifndef UTILS_COMP
#define UTILS_COMP

#include "constants.comp"

#ifdef IS_AVAILABLE_BUFFER_WORLD

struct RayCastResult{
    vec3 v;
    vec3 prev_v;
    bool found;
};


RayCastResult ray_cast(vec3 start, vec3 distance_and_direction) {
    //current voxel boundary
    vec3 v = floor(start);
    if(world[block_pos_into_world_idx( uvec3(v))]!=0) {
        return RayCastResult(v,v,true);
    }
    //final voxel boundary B
    vec3 b = start + distance_and_direction;
    vec3 bv = floor(b);
    vec3 step = sign(distance_and_direction);
    vec3 t_max = (max(step, 0) + v - start) / distance_and_direction; //notice that the signs will cancel out and the result will be positive
    vec3 t_delta = step / distance_and_direction;//notice that the signs will cancel out. Division by zero will yield +inf

    while(v != bv){
        uint min_dim = min_vec3_component(t_max);
        vec3 new_v = v;
        new_v[min_dim] += step[min_dim];
        if(world[block_pos_into_world_idx(uvec3(new_v))]!=0){
            return RayCastResult(new_v,v,true);
        }
        v = new_v;
        t_max[min_dim] += t_delta[min_dim];
    }
    return RayCastResult(v,v,false);
}

#endif //IS_AVAILABLE_BUFFER_WORLD


#ifdef IS_AVAILABLE_BUFFER_FACES
#ifdef IS_AVAILABLE_BUFFER_WORLD
uint remove_block_faces(const BlockProp p, uvec3 block_pos){
    ///////////////////////////////
    // FIRST WE COLLECT ALL THE NEIGHBOURING THAT USED TO BE COVERED AND WILL NOW BE UNCOVERED
    ///////////////////////////////
    uint chunk_x = block_pos.x / CHUNK_WIDTH;
    uint chunk_z = block_pos.z / CHUNK_DEPTH;
    uint chunk_idx = chunk_pos_into_chunk_idx(chunk_x,chunk_z);
    uint[6] orientations = uint[6](
        ZPlus,
        XPlus,
        YPlus,
        YMinus,
        XMinus,
        ZMinus
    );
    uvec3[6] neighbour_block_pos = uvec3[6](
        block_pos-uvec3(0,0,1),
        block_pos-uvec3(1,0,0),
        block_pos-uvec3(0,1,0),
        block_pos+uvec3(0,1,0),
        block_pos+uvec3(1,0,0),
        block_pos+uvec3(0,0,1)
    );
    bool[6] has_neighbour = bool[6](
        block_pos.z>0,
        block_pos.x>0,
        block_pos.y>0,
        block_pos.y+1<CHUNK_HEIGHT,
        block_pos.x+1<WORLD_WIDTH,
        block_pos.z+1<WORLD_DEPTH
    );
    uint[6] neighbour_block_ids;
    float[6] neighbour_opacity;
    block_pos.x -= chunk_x * CHUNK_WIDTH;
    block_pos.z -= chunk_z * CHUNK_DEPTH;
    uint number_of_opaque_blocks = 0;
    for(int i=0;i<6;i++){
        neighbour_block_ids[i] = has_neighbour[i] ? world[block_pos_into_world_idx(neighbour_block_pos[i])] : 0;
        neighbour_opacity[i] = has_neighbour[i] ? BLOCK_PROPS[neighbour_block_ids[i]].opacity : 0;
        if(neighbour_opacity[i] <= p.opacity && neighbour_block_ids[i] >= NO_OF_TRANSPARENT_BLOCKS) {
            number_of_opaque_blocks++;
        }
    }
    int[6] permutation = int[6](0,1,2,3,4,5); //these guys are sorted is such a way that iterating them will visit chunks in increasing chunk_idx order
    if(block_pos.z>0){
        permutation[1] = 0; // block_pos-uvec3(0,0,1)
        permutation[0] = 1; // block_pos-uvec3(1,0,0)
    }
    if(block_pos.z<15){
        permutation[4] = 5; // block_pos+uvec3(0,0,1)
        permutation[5] = 4; // block_pos+uvec3(1,0,0)
    }
    uvec3[7] faces_to_insert;
    uint[2] faces_to_insert_len = uint[](/*opaque index*/1,/*transparent index*/number_of_opaque_blocks+1);
    //    debugPrintfEXT("%d#%d",faces[0].x,faces[1].x);
    for(int j=0;j<6;j++){
        int i = permutation[j];
        uint neighbour = neighbour_block_ids[i];
        if(0 < neighbour && neighbour_opacity[i] <= p.opacity){

            uint orientation = orientations[i];
            uint chunk_x = neighbour_block_pos[i].x / CHUNK_WIDTH;
            uint chunk_z = neighbour_block_pos[i].z / CHUNK_DEPTH;
            neighbour_block_pos[i].x -= chunk_x * CHUNK_WIDTH;
            neighbour_block_pos[i].z -= chunk_z * CHUNK_DEPTH;

            uvec2 face_to_insert = new_face(neighbour_block_pos[i], orientation, chunk_x, chunk_z, BLOCK_PROPS[neighbour].texture_ids[orientation]);
            uint is_transparent = uint(neighbour < NO_OF_TRANSPARENT_BLOCKS);
            uint chunk_idx = chunk_pos_into_chunk_idx(chunk_x,chunk_z) + is_transparent*TOTAL_CHUNKS;
            faces_to_insert[faces_to_insert_len[is_transparent]++] = uvec3(face_to_insert,chunk_idx);
        }
    }
    faces_to_insert[0].z = 0xFFFFFFFFu; //Every cube has 6 faces. We use array of length 7, to ensure that array overflow never occurs.
    // The 0xFFFFFFFFu value has analogical purpose to the 0 in null terminated strings in C.

    uint face_offset = TOTAL_CHUNKS*2;
    ///////////////////////////////
    // THIS SECTION REMOVES FACES OF THE BLOCK THAT HAS BEEN REMOVED
    ///////////////////////////////
    int i=0;
    bool was_transparent = p.opacity < 1.0;
    for(;i<chunk_idx+(was_transparent?TOTAL_CHUNKS:0);i++){
        face_offset += faces[i].x;
    }
    uint length = faces[i].x;
    uint searched_face_coords = block_pos_relative_to_chunk_and_orientation_into_face_coords(uvec4(block_pos,XPlus));
    uint number_of_removed_faces = 0;
    for(uint face_idx=face_offset;face_idx < face_offset+length-number_of_removed_faces;face_idx++){
        while(face_coords_have_the_same_pos(faces[face_idx].x,searched_face_coords) && face_idx < face_offset+length-number_of_removed_faces){
            number_of_removed_faces += 1;
            faces[face_idx] = faces[face_offset+length-number_of_removed_faces];

        }
    }
    faces[i].x = length-number_of_removed_faces;
    face_offset += length;
    for(i+=1;i<TOTAL_CHUNKS*2;i++){
        length = faces[i].x;
        for(int j=0;j<number_of_removed_faces;){
            j++;
            faces[face_offset-j] = faces[face_offset+length-j];
        }
        face_offset += length;
    }
    face_offset-=number_of_removed_faces;// now this offset point to the end of face buffer
    ///////////////////////////////
    // THIS SECTION ADDS FACES OF NEIGHBOURS THAT WERE PREVIOUSLY HIDDEN AND ARE NOW BEING UNCOVERERD
    ///////////////////////////////
    uint faces_to_insert_idx = faces_to_insert_len[1]-1;
    uint final_face_count = face_offset + faces_to_insert_idx - TOTAL_CHUNKS*2;
    int total_number_of_inserted_faces = 0;
    i=2*int(TOTAL_CHUNKS)-1;
    for(;i>=0;i--){
        int length = int(faces[i].x);
        uint inserted_faces = 0;
        while (i==faces_to_insert[faces_to_insert_idx].z) {
            uvec2 new_face = faces_to_insert[faces_to_insert_idx].xy;
            faces_to_insert_idx--;
            faces[face_offset+faces_to_insert_idx] = new_face;
            inserted_faces++;
        }
        for(uint j=0;j<faces_to_insert_idx;j++){
            faces[face_offset+j] = faces[face_offset-length+j];
        }
        faces[i].x = length + inserted_faces;
        face_offset-=length;
    }
    return final_face_count;
}

uint add_block_faces(uvec3 block_pos, uint block_id){
    bool is_transparent = block_id < NO_OF_TRANSPARENT_BLOCKS;
    const BlockProp p = BLOCK_PROPS[block_id];
    uint chunk_x = block_pos.x / CHUNK_WIDTH;
    uint chunk_z = block_pos.z / CHUNK_DEPTH;
    uint chunk_idx = chunk_pos_into_chunk_idx(chunk_x,chunk_z);
    uint[6] orientations = uint[6](
        ZMinus,
        XMinus,
        YMinus,
        YPlus,
        XPlus,
        ZPlus
    );
    uvec3[6] neighbour_block_pos = uvec3[6](
        block_pos-uvec3(0,0,1),
        block_pos-uvec3(1,0,0),
        block_pos-uvec3(0,1,0),
        block_pos+uvec3(0,1,0),
        block_pos+uvec3(1,0,0),
        block_pos+uvec3(0,0,1)
    );

    bool[6] has_neighbour = bool[6](
        block_pos.z>0,
        block_pos.x>0,
        block_pos.y>0,
        block_pos.y+1<CHUNK_HEIGHT,
        block_pos.x+1<WORLD_WIDTH,
        block_pos.z+1<WORLD_DEPTH
    );
    block_pos.x -= chunk_x * CHUNK_WIDTH;
    block_pos.z -= chunk_z * CHUNK_DEPTH;

    float[6] neighbour_block_opacities;
    uint[6] neighbour_block_ids;
    uint opaque_neighbours = 0;
    for(int neighbour=0;neighbour<6;neighbour++){
        if(has_neighbour[neighbour]){
            uvec3 neighbour_pos = neighbour_block_pos[neighbour];
            neighbour_block_ids[neighbour] = world[block_pos_into_world_idx(neighbour_pos)];
            neighbour_block_opacities[neighbour] = BLOCK_PROPS[neighbour_block_ids[neighbour]].opacity;
            if( neighbour_block_opacities[neighbour] <= p.opacity && neighbour_block_ids[neighbour]>0 && neighbour_block_opacities[neighbour] == 1){
                opaque_neighbours++;
            }
        }
    }
    int[6] permutation = int[6](0,1,2,3,4,5); //these guys are sorted is such a way that iterating them will visit chunks in increasing chunk_idx order
    if(block_pos.z>0){
        permutation[1] = 0; // block_pos-uvec3(0,0,1)
        permutation[0] = 1; // block_pos-uvec3(1,0,0)
    }
    if(block_pos.z<15){
        permutation[4] = 5; // block_pos+uvec3(0,0,1)
        permutation[5] = 4; // block_pos+uvec3(1,0,0)
    }
    Face[6] faces_to_insert;
    uint faces_to_insert_len=0;
    uvec2[7] faces_to_remove;//first element are face coords. Second element is the face chunk index
    uint[2] faces_to_remove_len=uint[2](0,opaque_neighbours);
    for(int j=0;j<6;j++){
        int neighbour = permutation[j];
        if(has_neighbour[neighbour]){
            uvec3 neighbour_pos = neighbour_block_pos[neighbour];
            uint neighbour_block_id = neighbour_block_ids[neighbour];
            float neighbour_opacity = neighbour_block_opacities[neighbour];
            uint orientation = orientations[neighbour];
            if(neighbour_opacity < p.opacity){
                Face f = new_face(block_pos,orientation,chunk_x,chunk_z,p.texture_ids[orientation]);
                faces_to_insert[faces_to_insert_len++] = f;
            }
            if( neighbour_opacity <= p.opacity && neighbour_block_id>0 ){
                uint neighbour_chunk_x = neighbour_pos.x / CHUNK_WIDTH;
                uint neighbour_chunk_z = neighbour_pos.z / CHUNK_DEPTH;
                neighbour_pos.x -= neighbour_chunk_x * CHUNK_WIDTH;
                neighbour_pos.z -= neighbour_chunk_z * CHUNK_DEPTH;
                uint opposite = opposite_orientation(orientation);
                uint face_coords = block_pos_relative_to_chunk_and_orientation_into_face_coords(uvec4(neighbour_pos,opposite));
                uint is_transparent = uint(neighbour_opacity<1);
                uint neighbour_chunk_idx = chunk_pos_into_chunk_idx(neighbour_chunk_x,neighbour_chunk_z) + is_transparent*TOTAL_CHUNKS;
                faces_to_remove[faces_to_remove_len[is_transparent]++] = uvec2(face_coords,neighbour_chunk_idx);
            }
        }
    }
    faces_to_remove[faces_to_remove_len[1]].y = 0xFFFFFFFFu;


    uint face_offset = TOTAL_CHUNKS*2;
    uint i=0;
    uint chunk_faces_idx = chunk_idx + (is_transparent?TOTAL_CHUNKS:0);
    int faces_to_remove_idx = 0;
    for(;i<2*TOTAL_CHUNKS;i++){
        uint length = faces[i].x;

        for(uint j=0;j<faces_to_remove_idx;){
            j++;
            faces[face_offset-j] = faces[face_offset+length-j];
        }
        uint removed_faces = 0;
        uint from = face_offset-faces_to_remove_idx;
        while (i==faces_to_remove[faces_to_remove_idx].y) {
            uint coords = faces_to_remove[faces_to_remove_idx].x;
            for(uint j=from;j<from+length-removed_faces;j++){
                if(faces[j].x == coords){
                    removed_faces++;
                    faces[j] = faces[from+length-removed_faces];
                    break;
                }
            }
            faces_to_remove_idx++;
        }
        faces[i].x = length - removed_faces ;
        face_offset += length;
    }
    face_offset -= faces_to_remove_idx;
    const uint total_faces = face_offset - TOTAL_CHUNKS*2;
    for(int i=int(TOTAL_CHUNKS)*2-1;i>chunk_faces_idx;i--){
        uint length = faces[i].x;
        for(int j=0;j<faces_to_insert_len;j++){
            faces[face_offset+j] = faces[face_offset-length+j];
        }
        face_offset -= length;
    }
    for(int j=0;j<faces_to_insert_len;j++){
        faces[face_offset + j] = faces_to_insert[j];
    }
    faces[chunk_faces_idx].x += faces_to_insert_len;
    return total_faces + faces_to_insert_len;
}
#endif // IS_AVAILABLE_BUFFER_WORLD
#endif // IS_AVAILABLE_BUFFER_FACES



#endif // UTILS_COMP
