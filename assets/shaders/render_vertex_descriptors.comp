#ifndef PHYSICS_DESCRIPTORS_COMP
#define PHYSICS_DESCRIPTORS_COMP

#ifdef IS_AVAILABLE_BUFFER_MVP
layout (binding = 0) uniform Matrices{
    mat4 MVP;
    mat4 MV;
};
#endif

#ifdef IS_AVAILABLE_BUFFER_PARTICLES
#include "particle.comp"
layout(std430, binding = 2) buffer Particles{
    Particle particles[];
};
#endif // IS_AVAILABLE_BUFFER_PARTICLES

#ifdef IS_AVAILABLE_BUFFER_COLLISION_GRID
layout(std430, set = 0, binding = 3) buffer CollisionGrid{
    uint collision_grid[];
};
#endif // IS_AVAILABLE_BUFFER_COLLISION_GRID

#ifdef IS_AVAILABLE_BUFFER_CONSTRAINTS
#include "constraint.comp"
layout(std430, set = 0, binding = 4) buffer Constraints{
    Constraint constraints[];
};
#endif

#ifdef IS_AVAILABLE_BUFFER_INDIRECT
#include "indirect.comp"
#define DISPATCH_INDIRECT_COLLISION_DETECTION 0
#define DISPATCH_INDIRECT_SOLVE_CONSTRAINTS 1
#define DISPATCH_INDIRECT_UPDATE_BONES 2
#define DRAW_INDIRECT_BONES 0
#define DRAW_INDIRECT_BLOCK 1
layout(std430, set = 0, binding = 5) buffer Indirect{
    DispatchIndirectCommand[3] dispatch_indirect;
    DrawIndirectCommand[2] draw_indirect;
};
#endif //IS_AVAILABLE_BUFFER_INDIRECT

#ifdef IS_AVAILABLE_BUFFER_BONES
#include "bone.comp"
layout(std430, set = 0, binding = 6) buffer Bones{
    Bone bones[];
};
#endif


#ifdef IS_AVAILABLE_BUFFER_WORLD
#include "block.comp"
layout(std430, set = 0, binding = 7) buffer World{
    uint world[];
};
#endif

#ifdef IS_AVAILABLE_BUFFER_FACES
#include "face.comp"
layout(std430, set = 0, binding = 8) buffer Faces{
    // The first few faces are in fact, not faces at all!
    // Instead the faces at possitons 0..total_chunks are used to store the number of faces in eahc chunk.
    // For example faces[0].x stores the number of faces in first chunk, faces[1].x is second chunk and so on.
    // The chunks are indexed according to chunk_pos_into_chunk_idx().
    // Opaque faces need to be rendered first, before the transparent faces! For this reason the faces[] is split into
    // two regions, first for opaque, second for transparent. The faces at indices total_chunks..2*total_chunks store
    // the number of transparent faces at each chunk. So faces[0].x is the number of opaque faces in first chunk, while
    // faces[total_chunks].x is the number of transparent faces in first chunk. The very first actual face can be found at index
    // faces[2*total_chunks].
    // Notice that every face holds two numbers: coords and tex_idx. The faces at indices 0..2*total_chunks store the
    // number of faces in first component but  do not make
    // any use of the second component. Its value is undefined. However! Some algorithms do make use of the y component,
    // as a temporary storage purely for the purpose of some computations.
    Face faces[];
};
#endif //IS_AVAILABLE_BUFFER_FACES

#ifdef IS_AVAILABLE_BUFFER_BLOCK_PROPS
layout(std430, set = 0, binding = 9) buffer BlockProps{
    BlockProp block_props[];
};
#endif // IS_AVAILABLE_BUFFER_BLOCK_PROPS

#endif //PHYSICS_DESCRIPTORS_COMP