#version 450
//#extension GL_EXT_debug_printf : enable
#define IS_AVAILABLE_BUFFER_BONES
#define IS_AVAILABLE_BUFFER_GLOBAL_MUTABLES
#define IS_AVAILABLE_BUFFER_WORLD
#define IS_AVAILABLE_BUFFER_RAND_UINT

#include "descriptors_generate.comp"
layout (local_size_x_id = GROUP_SIZE_CONST_ID) in;
#include "utils.comp"

void main() {
    const uint gID = gl_GlobalInvocationID.x;
    if(gID < global_mutables.ann_entities){
        const uint rand_uint_offset = gID*2;
        const uvec2 rand_uint_offsets = uvec2(rand_uint_offset, rand_uint_offset+1) % MAX_RAND_UINT;
        const uvec2 rand_vec = uvec2(rand_uint[rand_uint_offsets.x], rand_uint[rand_uint_offsets.y]);
        const vec2 rand_pos_f = vec2(MAX_UVEC2 - rand_vec) / vec2(MAX_UVEC2);
        const uvec2 rand_pos = uvec2(rand_pos_f * WORLD_BORDERS.xz);
        uvec3 block_pos = uvec3(rand_pos.x, SEA_LEVEL, rand_pos.y);
        const uint block_idx = block_pos_into_world_idx(block_pos);
        const bool go_down = is_air(block_idx);
        const ivec3 block_idx_step_y_step_and_initial_y = go_down ? ivec3(-WORLD_BLOCK_STRIDE.y, -1, SEA_LEVEL+1) : ivec3(WORLD_BLOCK_STRIDE.y, 1, SEA_LEVEL);
        ivec2 block_idx_and_y = ivec2(block_idx+block_idx_step_y_step_and_initial_y.x, block_idx_step_y_step_and_initial_y.y+block_idx_step_y_step_and_initial_y.z);
        const uint limit = block_pos_into_world_idx(uvec3(rand_pos.x, go_down ? 0 : CHUNK_HEIGHT-1, rand_pos.y));
        while (block_idx_and_y.x!=limit && is_air(block_idx_and_y.x)==go_down){
            block_idx_and_y+=block_idx_step_y_step_and_initial_y.xy;
        }
        const vec3 agent_pos = vec3(rand_pos.x, block_idx_and_y.y, rand_pos.y)+vec3(0.5,0.5,0.5);
        const uint agent_entity_idx = gID;
        const Bone agent_bone = Bone(
            agent_pos, // vec3 new_center;
            0.48, // float half_side_length;//width == 2*half_side_length && depth == 2*half_side_length
            vec3(1, 0, 0), // vec3 direction;
            0.48, // float half_height;
            vec3(0, 0, 0), // vec3 impulse;
            1, // float mass;
            agent_pos, // vec3 old_center;
            encode_ann_entity_idx(agent_entity_idx), // uint entity_idx;
            vec3(0, 0, 0), // vec3 position_relative_to_parent;
            0, // uint parent_bone_idx;
            vec4(rand_pos_f, rand_pos_f)// vec4 texture_coords;//xy components hold text UV coordinates. zw components hold width and height
        );
        bones[gID] = agent_bone;
    }
}