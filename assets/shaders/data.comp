#ifndef DATA_COMP
#define DATA_COMP
#include "constants.comp"

struct Particle{
    vec3 old_position;
    float size;
    vec3 new_position;
    float color;
};

struct Constraint{
    int particle1; // if negative, then the actual particle ID is obtained by negating this value. Moreover,
        // negative numbers are used to specify that the constraint is an inequality:
        // dist(particles[-particle1].position, particles[particle2].position) <= constant_param
        // If the value is positive, then the constraint is an equality
        // dist(particles[particle1].position, particles[particle2].position) == constant_param
    int particle2;
    float constant_param; // If this value is negative, then the constraint is an inequality
        // that keeps the particles away from one another
        // dist(particles[particle1].position, particles[particle2].position) >= -constant_param
};

struct Bone{
    uvec4 particle_ids;
    uint texture_variant;
    uint part_variant;
    uint dummy_field0;
    uint dummy_field1;
};

int cell_position_to_idx(ivec3 cell_position){
    return cell_position.x+(cell_position.y+cell_position.z*CHUNK_HEIGHT_IN_CELLS)*CHUNK_WIDTH_IN_CELLS;
}

Constraint collision_constraint(uint particle1, uint particle2){
    Constraint c;
    c.particle1 = int(particle1);
    c.particle2 = int(particle2);
    c.constant_param = -PARTICLE_DIAMETER;
    return c;
}

struct DispatchIndirectCommand{
    uint    x;
    uint    y;
    uint    z;
};

#endif // DATA_COMP