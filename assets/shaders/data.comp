
struct Particle{
    vec3 old_position;
    float size;
    vec3 new_position;
    float color;
};

struct Constraint{
    int particle1; // if negative, then the actual particle ID is obtained by negating this value. Moreover,
        // negative numbers are used to specify that the constraint is an inequality:
        // dist(particles[-particle1].position, particles[particle2].position) <= constant_param
        // If the value is positive, then the constraint is an equality
        // dist(particles[particle1].position, particles[particle2].position) == constant_param
    int particle2;
    float constant_param; // If this value is negative, then the constraint is an inequality
        // that keeps the particles away from one another
        // dist(particles[particle1].position, particles[particle2].position) >= -constant_param
};

struct Bone{
    vec3 phantom; // position of phantom particle, relative to the particle1.
    // The phantom particle does not participate in collision detection. It's merely used
    // for the purpose of rendering (so that we know where the front of the bone is) and
    // as an extra anchor for building distance constraints
    uint particle1;
    uint particle2;
    vec3 direction;
    int parent; // -1 if no parent
};

int cell_position_to_idx(ivec3 cell_position){
    return cell_position.x+(cell_position.y+cell_position.z*CHUNK_HEIGHT_IN_CELLS)*CHUNK_WIDTH_IN_CELLS;
}

Constraint collision_constraint(uint particle1, uint particle2){
    Constraint c;
    c.particle1 = int(particle1);
    c.particle2 = int(particle2);
    c.constant_param = -PARTICLE_DIAMETER;
    return c;
}