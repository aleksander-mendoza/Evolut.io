#version 450

#include "constants.comp"
#include "data.comp"

layout (local_size_x = 32) in;


layout (set = 0, binding = 0) uniform Throw{
    vec3 position;
    vec3 velocity;
}throw;

layout (set = 0, binding = 1) buffer ParticleConstants{
    int predefined_constraints;
    int collision_constraints;
    int chunks_x;
    int chunks_z;
};

layout(std430, set = 0, binding = 2) buffer Particles{
    Particle particles[];
};

layout(std430, set = 0, binding = 3) buffer Velocity{
    Vec3 velocities[];
};

layout(std430, set = 0, binding = 4) buffer CollisionGrid{
    uint collision_grid[];
};

layout(std430, set = 0, binding = 5) buffer Constraints{
    Constraint constraints[];
};

void main()
{
    //grab global ID
    uint gID = gl_GlobalInvocationID.x;
    if(gID==0){
        collision_constraints = 0; //First we zero-out the number of computed collision constraints
        if(throw.velocity!=vec3(0,0,0)){
            particles[0].position = throw.position;
            velocities[0] = from_vec3(throw.velocity);
        }
    }
    const vec3 position = particles[gID].position;
    vec3 velocity = to_vec3(velocities[gID]);
    vec3 candidate_position = position + velocity;
    //The below code is a branchless test for bounding-box collision. It's equivalent to the code
    // if(candidate_position.x<0){candidate_position.x=-candidate_position.x;}
    // if(candidate_position.x>16*chunks_x){candidate_position.x=16*chunks_x-(candidate_position.x-16*chunks_x);}
    //and so on for each x,y,z coordinate.
    vec3 new_position = candidate_position - 2*min(candidate_position,vec3(0,0,0)) + 2*min(vec3(16,16,16)-candidate_position,vec3(0,0,0));
    particles[gID].position = new_position;
    //grab global ID
    for(int chunk_x=0;chunk_x<chunks_x;chunk_x++){
        for(int chunk_z=0;chunk_z<chunks_z;chunk_z++){
            if(int(new_position.x)/CHUNK_WIDTH==chunk_x && int(new_position.z)/CHUNK_DEPTH==chunk_z){
                vec3 chunk_relative_pos = new_position; //- vec3(chunk_x*CHUNK_WIDTH,0,chunk_z*CHUNK_DEPTH);
                const ivec3 cell_position = ivec3(chunk_relative_pos/(CELL_SIZE));
                const int cell_idx = cell_position_to_idx(cell_position);
                collision_grid[cell_idx] = gID;
                //Comment explaining what happens below:
                //Notice that PARTICLE_DIAMETER is so large that it's possible for two cells, one contained in cell (x,y,z)
                //and another one in cell (x+2,y,z) to collide. Hence we need to check for collisions not only with neighbouring cells,
                //but also with heighbours of those reighbours. This gives us 5x5x5=125 cells to check. It's a lot!
                // A substantial optimsiation can be made if we notice that particle in cell (x,y,z) can callide with particle in
                // call (x+2,y,z) only under the condition that the center of first particle is close to the left side of its cell
                // and the center of second particle is closer to the right side of its cell. For example particle at
                // (4.89,y,z) may potentially collide with particle at (6.13,y,z), but it cannot collide with (6.51,y,z)
                // or (2.90,y,z). Hence we can narrow down the search area to 4x4x4=64 cells. It's 50% speedup!
                // cell_position.x+ivec2(-1,3) -- this is the range spanning once cell to the left and two cells to the right
                // int(particle.x)==int(particle.x-0.5)  -- this checks whether particle is on the right side of the cell
                // If the particle is on the right side of the cell, then the expresion evaluates to false, which gives us 0 after casting to int and
                // subtraction becomes a no-op. If the particle is one the left side, then the bool becomes 1 and we subtract it from both ends of range, which
                // leaves us with a range spanning two cells to the left and one cell to the right.
                // ivec3 is_on_the_left = ivec3(equal(ivec3(particle),ivec3(particle+0.5)));
                /* The final code could look like this:
                ivec2 x_range=clamp(cell_position.x+ivec2(-1,3)-is_on_the_left.x,0,CHUNK_WIDTH_IN_CELLS); //r_range is inclusive on the left and exclusive on the right
                ivec2 y_range=clamp(cell_position.y+ivec2(-1,3)-is_on_the_left.y,0,CHUNK_HEIGHT_IN_CELLS);
                ivec2 z_range=clamp(cell_position.z+ivec2(-1,3)-is_on_the_left.z,0,CHUNK_DEPTH_IN_CELLS);
                */
                //However, notice that we are running collision detection for every particle. In means that if particle
                // A collides with particle B, the collision will be detected twice by two different threads. One detecting that
                // A collides with B and the other that B collides with A. But it's only enough to detect the collision once. Hence
                // we don't need to check the entire range ivec2(-1,3)-is_on_the_left.x . Instead we can clamp it on one side
                // and obtain range ivec2(-1-is_on_the_left.x,1) . This further narrows down the search area from 4x4x4 to
                // 2x2x2 or 2x3x2 or 3x3x2 .. and so on, depending on the values of is_on_the_left. And since the right bound of the range
                // is constant we can factor it out
                /*
                int from_x_inclusive=max(0, cell_position.x-1-is_on_the_left.x); // to_x_inclusive=cell_position.x<CHUNK_WIDTH_IN_CELLS
                int from_y_inclusive=max(0, cell_position.y-1-is_on_the_left.y); // to_y_inclusive=cell_position.y<CHUNK_HEIGHT_IN_CELLS
                int from_z_inclusive=max(0, cell_position.z-1-is_on_the_left.z); // to_z_inclusive=cell_position.z<CHUNK_DEPTH_IN_CELLS
                */
                //This can be further reduced to
                /*
                ivec3 is_on_the_left = ivec3(equal(ivec3(chunk_relative_pos),ivec3(chunk_relative_pos+0.5)));
                ivec3 from_inclusive = max(cell_position-1-is_on_the_left, 0);
                */
                // Which can be reduced even further:
                const ivec3 from_inclusive = max(ivec3(chunk_relative_pos/(CELL_SIZE)+0.5)-2, 0); // that's a beautiful and very efficient result, isn't it?
                // now we are ready to check collisions
                uint loops = 0;
                for(int x=from_inclusive.x;x<=cell_position.x;x++) {
                    for(int y=from_inclusive.y;y<=cell_position.y;y++) {
                        for(int z=from_inclusive.z;z<=cell_position.z;z++) {
                            loops += 1;
                            const int cell_idx = cell_position_to_idx(ivec3(x,y,z));
                            const uint neighbour_particle_id = collision_grid[cell_idx];
                            if(neighbour_particle_id!=gID && neighbour_particle_id<(MAX_UINT)){//look! If somehow there
                                // happen to be two particles that fall into the same grid cell, then one will override the other
                                // but it doesn't matter! They will both visit this cell and one of them will fail
                                // the neighbour_particle_id!=gID test, while the other one will not. Hence the collision
                                // will be detected anyway. This holds true even if there are three or more particles crammed
                                // in the same cell. They won't all collide with each other, but there will always be one
                                // arbitrarily chosen particle, that will collide with all of the other (because they will
                                // pass the neighbour_particle_id!=gID test).
                                const vec3 neighbour_particle = particles[neighbour_particle_id].position;
                                new_position = particles[gID].position;
                                const vec3 distance_vector = new_position - neighbour_particle;
                                const float distance_square = dot(distance_vector, distance_vector);
                                if(0< distance_square && distance_square<=(PARTICLE_COLLISION_DISTANCE_SQUARE)){
    //                                uint my_collision_constraint_index = atomicAdd(collision_constraints, 1);
    //                                Constraint c;
    //                                c.particle1 = gID;
    //                                c.particle2 = neighbour_particle_idx;
    //                                constraints[my_collision_constraint_index] = c;
                                    const float distance = sqrt(distance_square);
                                    const vec3 collision_projection_delta = 0.5 * (distance - (PARTICLE_DIAMETER))*distance_vector/distance;
                                    new_position -= collision_projection_delta;
                                    particles[neighbour_particle_id].position = neighbour_particle + collision_projection_delta;
                                    particles[gID].position = new_position;
                                }
                            }
                        }
                    }
                }
                collision_grid[cell_idx] = MAX_UINT; // Cleanup after we're done with collision detection.
                // This ensures that the grid is kept zeroed-out and ready for the next iteration
            }
        }
    }
    vec3 new_velocity = particles[gID].position - position;
    velocities[gID] = from_vec3(new_velocity);

}

