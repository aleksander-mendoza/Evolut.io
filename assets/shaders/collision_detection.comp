#version 450
#extension GL_EXT_debug_printf : enable
#include "constants.comp"
#include "data.comp"
#include "world.comp"

layout (local_size_x = 32) in;

#include "physics_descriptors.comp"

uint max_vec3_component(vec3 v){
    return v.x > v.y ? (v.x > v.z ? 0 : 2) : (v.y > v.z ? 1 : 2);
}

vec3 compute_new_position(uint id){
    const uint world_width = constants.chunks_x*CHUNK_WIDTH;
    const uint world_area = world_width*constants.chunks_z*CHUNK_DEPTH;
    const vec3 old_position = particles[id].old_position;
    const vec3 current_position = particles[id].new_position;
    vec3 velocity = current_position - old_position;
    velocity.y -= GRAVITY;
    vec3 new_position = current_position + velocity;
    //TODO: implement damping, drag, friction, gravity etc. The velocity variable might be useful here
    //The below code is a branchless test for bounding-box collision. It's equivalent to the code
    // if(candidate_position.x<0){candidate_position.x=-candidate_position.x;}
    // if(candidate_position.x>16*constants.chunks_x){candidate_position.x=16*constants.chunks_x-(candidate_position.x-16*constants.chunks_x);}
    //and so on for each x,y,z coordinate.
    new_position = new_position - 2*min(new_position, vec3(0, 0, 0)) + 2*min(vec3(16, 16, 16)-new_position, vec3(0, 0, 0));
    uvec3 block_position = uvec3(new_position);
    const uint block_idx = block_pos_into_world_idx(world_width, world_area, block_position);
    const uint block = world[block_idx];
    if (block > 0) {
        vec3 pos_relative_to_block = new_position - block_position;
        uint max_comp = max_vec3_component(abs(pos_relative_to_block-vec3(0.5,0.5,0.5)));
        new_position[max_comp] += 2.*(block_position[max_comp] + round(pos_relative_to_block[max_comp]) - new_position[max_comp]);
    }
    particles[id].old_position = current_position;
    particles[id].new_position = new_position;
    return new_position;
}

void main()
{
    uint gID = gl_GlobalInvocationID.x;
    if(gID==0){
        constants.collision_constraints = constants.predefined_constraints; //First we reset the number of computed collision constraints
        if(player_event.event_type==PLAYER_EVENT_THROW){
            // vec3_slot0 holds current player position
            // vec3_slot1 holds throwing velocity
            particles[0].old_position = player_event.vec3_slot0;
            particles[0].new_position = player_event.vec3_slot0 + player_event.vec3_slot1;
        }
    }

    if (gID < constants.solid_particles){
        vec3 new_position = compute_new_position(gID);
        for (int chunk_x=0;chunk_x<constants.chunks_x;chunk_x++){
            for (int chunk_z=0;chunk_z<constants.chunks_z;chunk_z++){
                if (int(new_position.x)/CHUNK_WIDTH==chunk_x && int(new_position.z)/CHUNK_DEPTH==chunk_z){
                    vec3 chunk_relative_pos = new_position;//- vec3(chunk_x*CHUNK_WIDTH,0,chunk_z*CHUNK_DEPTH);
                    const ivec3 cell_position = ivec3(chunk_relative_pos/(CELL_SIZE));
                    const int cell_idx = cell_position_to_idx(cell_position);
                    collision_grid[cell_idx] = gID;
                    //Comment explaining what happens below:
                    //Notice that PARTICLE_DIAMETER is so large that it's possible for two cells, one contained in cell (x,y,z)
                    //and another one in cell (x+2,y,z) to collide. Hence we need to check for collisions not only with neighbouring cells,
                    //but also with heighbours of those reighbours. This gives us 5x5x5=125 cells to check. It's a lot!
                    // A substantial optimsiation can be made if we notice that particle in cell (x,y,z) can callide with particle in
                    // call (x+2,y,z) only under the condition that the center of first particle is close to the left side of its cell
                    // and the center of second particle is closer to the right side of its cell. For example particle at
                    // (4.89,y,z) may potentially collide with particle at (6.13,y,z), but it cannot collide with (6.51,y,z)
                    // or (2.90,y,z). Hence we can narrow down the search area to 4x4x4=64 cells. It's 50% speedup!
                    // cell_position.x+ivec2(-1,3) -- this is the range spanning once cell to the left and two cells to the right
                    // int(particle.x)==int(particle.x-0.5)  -- this checks whether particle is on the right side of the cell
                    // If the particle is on the right side of the cell, then the expresion evaluates to false, which gives us 0 after casting to int and
                    // subtraction becomes a no-op. If the particle is one the left side, then the bool becomes 1 and we subtract it from both ends of range, which
                    // leaves us with a range spanning two cells to the left and one cell to the right.
                    // ivec3 is_on_the_left = ivec3(equal(ivec3(particle),ivec3(particle+0.5)));
                    /* The final code could look like this:
                    ivec2 x_range=clamp(cell_position.x+ivec2(-1,3)-is_on_the_left.x,0,CHUNK_WIDTH_IN_CELLS); //r_range is inclusive on the left and exclusive on the right
                    ivec2 y_range=clamp(cell_position.y+ivec2(-1,3)-is_on_the_left.y,0,CHUNK_HEIGHT_IN_CELLS);
                    ivec2 z_range=clamp(cell_position.z+ivec2(-1,3)-is_on_the_left.z,0,CHUNK_DEPTH_IN_CELLS);
                    */
                    //However, notice that we are running collision detection for every particle. In means that if particle
                    // A collides with particle B, the collision will be detected twice by two different threads. One detecting that
                    // A collides with B and the other that B collides with A. But it's only enough to detect the collision once. Hence
                    // we don't need to check the entire range ivec2(-1,3)-is_on_the_left.x . Instead we can clamp it on one side
                    // and obtain range ivec2(-1-is_on_the_left.x,1) . This further narrows down the search area from 4x4x4 to
                    // 2x2x2 or 2x3x2 or 3x3x2 .. and so on, depending on the values of is_on_the_left. And since the right bound of the range
                    // is constant we can factor it out
                    /*
                    int from_x_inclusive=max(0, cell_position.x-1-is_on_the_left.x); // to_x_inclusive=cell_position.x<CHUNK_WIDTH_IN_CELLS
                    int from_y_inclusive=max(0, cell_position.y-1-is_on_the_left.y); // to_y_inclusive=cell_position.y<CHUNK_HEIGHT_IN_CELLS
                    int from_z_inclusive=max(0, cell_position.z-1-is_on_the_left.z); // to_z_inclusive=cell_position.z<CHUNK_DEPTH_IN_CELLS
                    */
                    //This can be further reduced to
                    /*
                    ivec3 is_on_the_left = ivec3(equal(ivec3(chunk_relative_pos),ivec3(chunk_relative_pos+0.5)));
                    ivec3 from_inclusive = max(cell_position-1-is_on_the_left, 0);
                    */
                    // Which can be reduced even further:
                    const ivec3 from_inclusive = max(ivec3(chunk_relative_pos/(CELL_SIZE)+0.5)-2, 0);// that's a beautiful and very efficient result, isn't it?
                    // now we are ready to check collisions
                    for (int x=from_inclusive.x;x<=cell_position.x;x++) {
                        for (int y=from_inclusive.y;y<=cell_position.y;y++) {
                            for (int z=from_inclusive.z;z<=cell_position.z;z++) {
                                const int cell_idx = cell_position_to_idx(ivec3(x, y, z));
                                const uint neighbour_particle_id = collision_grid[cell_idx];
                                if (neighbour_particle_id!=gID && neighbour_particle_id<(MAX_UINT)){ //look! If somehow there
                                    // happen to be two particles that fall into the same grid cell, then one will override the other
                                    // but it doesn't matter! They will both visit this cell and one of them will fail
                                    // the neighbour_particle_id!=gID test, while the other one will not. Hence the collision
                                    // will be detected anyway. This holds true even if there are three or more particles crammed
                                    // in the same cell. They won't all collide with each other, but there will always be one
                                    // arbitrarily chosen particle, that will collide with all of the other (because they will
                                    // pass the neighbour_particle_id!=gID test).
                                    const vec3 neighbour_particle = particles[neighbour_particle_id].new_position;
                                    const vec3 distance_vector = new_position - neighbour_particle;
                                    const float distance_square = dot(distance_vector, distance_vector);
                                    if (0 < distance_square &&// we need to check this, because division by zero leads to algorithm instability
                                    distance_square<=(PARTICLE_COLLISION_DISTANCE_SQUARE)){
                                        uint my_collision_constraint_index = atomicAdd(constants.collision_constraints, 1);
                                        constraints[my_collision_constraint_index] = collision_constraint(gID, neighbour_particle_id);
                                    }
                                }
                            }
                        }
                    }
                    collision_grid[cell_idx] = MAX_UINT;// Cleanup after we're done with collision detection.
                    // This ensures that the grid is kept zeroed-out and ready for the next iteration
                }
            }
        }
    }
    if(gID==0){
        dispatch_indirect[DISPATCH_INDIRECT_SOLVE_CONSTRAINTS].x = uint(ceil(float(constants.collision_constraints)/32.));
    }
    if (gID < constants.phantom_particles){
        compute_new_position(gID+constants.solid_particles);
    }
}

