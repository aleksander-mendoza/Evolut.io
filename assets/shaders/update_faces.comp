
#ifndef UPDATE_FACES_COMP
#define UPDATE_FACES_COMP
#ifdef IS_AVAILABLE_BUFFER_FACES
#ifdef IS_AVAILABLE_BUFFER_BLOCK_PROPS
#ifdef IS_AVAILABLE_BUFFER_WORLD
#include "particle_constants.comp"
#include "constants.comp"
#include "face.comp"
#include "world.comp"


uint add_block_neighboring_faces(const ParticleConstants c, const BlockProp p, uvec3 block_pos){
    uint chunk_x = block_pos.x / CHUNK_WIDTH;
    uint chunk_z = block_pos.z / CHUNK_DEPTH;
    uint chunk_idx = chunk_pos_into_chunk_idx(c,chunk_x,chunk_z);
    uint[6] orientations = uint[6](
        ZPlus,//these guys are sorted is such a way that iterating them will visit chunks by increasing chunk_idx order
        XPlus,
        YPlus,
        YMinus,
        XMinus,
        ZMinus
    );
    uvec3[6] neighbour_block_pos = uvec3[6](
        block_pos-uvec3(0,0,1),
        block_pos-uvec3(1,0,0),
        block_pos-uvec3(0,1,0),
        block_pos+uvec3(0,1,0),
        block_pos+uvec3(1,0,0),
        block_pos+uvec3(0,0,1)
    );
    bool[6] has_neighbour = bool[6](
        block_pos.z>0,
        block_pos.x>0,
        block_pos.y>0,
        block_pos.y+1<CHUNK_HEIGHT,
        block_pos.x+1<c.world_width,
        block_pos.z+1<c.world_depth
    );
    uint[6] neighbour_block_ids;
    float[6] neighbour_opacity;
    block_pos.x -= chunk_x * CHUNK_WIDTH;
    block_pos.z -= chunk_z * CHUNK_DEPTH;
    uint number_of_opaque_blocks = 0;
    for(int i=0;i<6;i++){
        neighbour_block_ids[i] = has_neighbour[i] ? world[block_pos_into_world_idx(c, neighbour_block_pos[i])] : 0;
        neighbour_opacity[i] = has_neighbour[i] ? block_props[neighbour_block_ids[i]].opacity : 0;
        if(neighbour_opacity[i] <= p.opacity) {
            number_of_opaque_blocks++;
        }
    }

    uvec3[7] faces_to_insert;
    uint[2] faces_to_insert_len = uint[](/*opaque index*/0,/*transparent index*/number_of_opaque_blocks);
    for(int i=0;i<6;i++){
        uint neighbour = neighbour_block_ids[i];
        if(0 < neighbour && neighbour_opacity[i] <= p.opacity){

            uint orientation = orientations[i];
            uint chunk_x = neighbour_block_pos[i].x / CHUNK_WIDTH;
            uint chunk_z = neighbour_block_pos[i].z / CHUNK_DEPTH;
            neighbour_block_pos[i].x -= chunk_x * CHUNK_WIDTH;
            neighbour_block_pos[i].z -= chunk_z * CHUNK_DEPTH;

            uvec2 face_to_insert = new_face(neighbour_block_pos[i], orientation, chunk_x, chunk_z, block_props[neighbour].texture_ids[orientation]);
            uint is_transparent = uint(neighbour < NO_OF_TRANSPARENT_BLOCKS);
            uint chunk_idx = chunk_pos_into_chunk_idx(c,chunk_x,chunk_z) + is_transparent*c.total_chunks;
            faces_to_insert[faces_to_insert_len[is_transparent]++] = uvec3(face_to_insert,chunk_idx);
        }
    }
    faces_to_insert[faces_to_insert_len[1]].z = 0xFFFFFFFFu; //Every cube has 6 faces. We use array of length 7, to ensure that array overflow never occurs.
    // The 0xFFFFFFFFu value has analogical purpose to the 0 in null terminated strings in C.

    int number_of_removed_faces = 0;
    uint face_offset = c.total_chunks*2;
    uint i=0;
    int length = 0;
    for(;i<2*c.total_chunks;i++){
        length += int(faces[i].x);
        face_offset += length;
        int faces_to_insert_idx = 0;
        while (i==faces_to_insert[faces_to_insert_idx].z) {
            uvec2 new_face = faces_to_insert[faces_to_insert_idx].xy;
            uvec2 replaced_face = faces[face_offset];
            faces_to_insert[faces_to_insert_idx].xy = replaced_face;
            faces[face_offset] = new_face;
            faces_to_insert[faces_to_insert_idx].z++;
            faces_to_insert_idx++;
            face_offset++;

        }
        faces[i].x = length + faces_to_insert_idx;
        length = -faces_to_insert_idx;
    }
    return face_offset-c.total_chunks*2;
}


uint remove_block_faces(const ParticleConstants c, uvec3 block_pos, bool was_transparent){

    uint chunk_x = block_pos.x / CHUNK_WIDTH;
    uint chunk_z = block_pos.z / CHUNK_DEPTH;
    block_pos.x -= chunk_x * CHUNK_WIDTH;
    block_pos.z -= chunk_z * CHUNK_DEPTH;
    uint chunk_idx = chunk_pos_into_chunk_idx(c,chunk_x,chunk_z);
    uint face_offset = c.total_chunks*2;
    uint i=0;
    for(;i<chunk_idx+(was_transparent?c.total_chunks:0);i++){
        face_offset += faces[i].x;
    }
    uint length = faces[i].x;
    uint searched_face_coords = block_pos_relative_to_chunk_and_orientation_into_face_coords(uvec4(block_pos,XPlus));
    uint number_of_removed_faces = 0;
    for(uint face_idx=face_offset;face_idx < face_offset+length;face_idx++){
        while(face_coords_have_the_same_pos(faces[face_idx].x,searched_face_coords) && face_idx < face_offset+length){
            number_of_removed_faces += 1;
            length -= 1;
            faces[face_idx] = faces[face_offset+length];

        }
    }
    faces[i].x = length;
    face_offset += length;
    for(i+=1;i<c.total_chunks*2;i++){
        length = faces[i].x;
        for(int j=0;j<number_of_removed_faces;j++){
            length -= 1;
            faces[face_offset+j] = faces[face_offset+number_of_removed_faces+length];
        }
        face_offset += length+number_of_removed_faces;
    }
    return face_offset-c.total_chunks*2;
}


uint add_block_faces(const ParticleConstants c, uvec3 block_pos, uint block_id){
    bool is_transparent = block_id < NO_OF_TRANSPARENT_BLOCKS;
    const BlockProp p = block_props[block_id];
    uint chunk_x = block_pos.x / CHUNK_WIDTH;
    uint chunk_z = block_pos.z / CHUNK_DEPTH;
    uint chunk_idx = chunk_pos_into_chunk_idx(c,chunk_x,chunk_z);
    uint[6] orientations = uint[6](
        ZMinus,//these guys are sorted is such a way that iterating them will visit chunks by increasing chunk_idx order
        XMinus,
        YMinus,
        YPlus,
        XPlus,
        ZPlus
    );
    uvec3[6] neighbour_block_pos = uvec3[6](
        block_pos-uvec3(0,0,1),
        block_pos-uvec3(1,0,0),
        block_pos-uvec3(0,1,0),
        block_pos+uvec3(0,1,0),
        block_pos+uvec3(1,0,0),
        block_pos+uvec3(0,0,1)
    );

    bool[6] has_neighbour = bool[6](
        block_pos.z>0,
        block_pos.x>0,
        block_pos.y>0,
        block_pos.y+1<CHUNK_HEIGHT,
        block_pos.x+1<c.world_width,
        block_pos.z+1<c.world_depth
    );
    block_pos.x -= chunk_x * CHUNK_WIDTH;
    block_pos.z -= chunk_z * CHUNK_DEPTH;

    Face[6] faces_to_insert;
    uint faces_to_insert_len=0;
    for(int neighbour=0;neighbour<6;neighbour++){
        if(has_neighbour[neighbour]){
            uint neighbour_block_id = world[block_pos_into_world_idx(c, neighbour_block_pos[neighbour])];
            const BlockProp neighbour_p = block_props[neighbour_block_id];
            if(neighbour_p.opacity < p.opacity){
                uint orientation = orientations[neighbour];
                faces_to_insert[faces_to_insert_len++] = new_face(block_pos,orientation,chunk_x,chunk_z,p.texture_ids[orientation]);
            }
        }
    }

    uint face_offset = c.total_chunks*2;
    uint i=0;
    uint chunk_faces_idx = chunk_idx + (is_transparent?c.total_chunks:0);
    for (;i<chunk_faces_idx;i++) {
        face_offset += faces[i].x;
    }
    for(;i<2*c.total_chunks;i++){
        face_offset += faces[i].x;
        for(int faces_to_insert_idx=0;faces_to_insert_idx<faces_to_insert_len;faces_to_insert_idx++){
            Face new_face = faces_to_insert[faces_to_insert_idx];
            Face replaced_face = faces[face_offset];
            faces_to_insert[faces_to_insert_idx] = replaced_face;
            faces[face_offset] = new_face;
            face_offset++;
        }
    }
    faces[chunk_faces_idx].x += faces_to_insert_len;
    return face_offset-c.total_chunks*2;
}
#endif // IS_AVAILABLE_BUFFER_WORLD
#endif // IS_AVAILABLE_BUFFER_BLOCK_PROPS
#endif // IS_AVAILABLE_BUFFER_FACES
#endif // UPDATE_FACES_COMP